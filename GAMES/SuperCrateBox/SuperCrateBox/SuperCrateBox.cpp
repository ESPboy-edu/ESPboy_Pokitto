#include <Arduino.h>
#include "SuperCrateBox.h"
#include "platform_Pokitto.h"
#include "sounds.h"
#include "maintheme.h"


#include "../libs/LibAudio/LibAudio.h"
Audio::Sink<3, 8000> audio;

Pokitto::Core pb;

/*
#ifdef ESP8266
    #include "platform_Picoboy.h"
#else
    #include "../platform_Pokitto.h"
#endif // ESP8266
*/
#define VERSION "V1.0"

bool getBitmapPixel(const uint8_t* bitmap, uint8_t x, uint8_t y){
  return pgm_read_byte(bitmap+2 + y * ((pgm_read_byte(bitmap)+7)/8) + (x >> 3)) & (B10000000 >> (x % 8));
}

bool collideRectRect(int16_t x1, int16_t y1, int16_t w1, int16_t h1 ,int16_t x2 ,int16_t y2, int16_t w2, int16_t h2){
  return !( x2 >= x1+w1 || x2+w2 <= x1 || y2 >= y1+h1 || y2+h2 <= y1);
}

const uint8_t bl_ackrain[] PROGMEM =
{
    64,12,
    0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xe0,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x70,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0x07,0x70,0x07,0x77,0x70,0x07,0x77,0x77,0x07,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x70,0x07,0x77,0x70,0x07,0x77,0x70,0x70,0x77,0x77,0x00,0x00,0x70,0x00,0x00,0x70,0x07,0x77,0x77,0x0e,0x07,0x77,0x77,0x00,0x77,0x77,0x07,0x70,0x77,0x77,0x70,
    0x07,0x70,0x07,0x77,0x70,0x07,0x77,0x70,0x70,0x77,0x77,0x77,0x00,0x70,0x07,0x00,0x70,0x07,0x00,0x77,0x0e,0x07,0x70,0x77,0x00,0x00,0x77,0x00,0x00,0x77,0x07,0x70,
    0x07,0x70,0x00,0x00,0x70,0x07,0x77,0x07,0x77,0x07,0x70,0x00,0x00,0x70,0x07,0x77,0x70,0x00,0x77,0x77,0x0e,0x07,0x70,0x00,0x07,0x77,0x77,0x07,0x70,0x77,0x07,0x70,
    0x07,0x70,0x07,0x00,0x70,0x07,0x77,0x07,0x77,0x07,0x70,0x07,0x00,0x70,0x07,0x77,0x70,0x07,0x00,0x77,0x0e,0x07,0x70,0xee,0x07,0x70,0x77,0x07,0x70,0x77,0x07,0x70,
    0x07,0x70,0x07,0x00,0x70,0x07,0x77,0x70,0x00,0x77,0x70,0x07,0x00,0x70,0x07,0x77,0x70,0x07,0x00,0x77,0x0e,0x07,0x70,0xee,0x07,0x70,0x77,0x07,0x70,0x77,0x07,0x70,
    0x07,0x70,0x07,0x00,0x70,0x07,0x77,0x77,0x77,0x77,0x70,0x07,0x00,0x70,0x07,0x00,0x70,0x07,0x00,0x77,0x0e,0x07,0x70,0xee,0x07,0x70,0x77,0x07,0x70,0x77,0x07,0x70,
    0x07,0x70,0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x70,0x07,0x00,0x77,0x0e,0x07,0x70,0xee,0x07,0x77,0x77,0x07,0x70,0x77,0x07,0x70,
    0xe0,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x70,0xee,0x00,0x00,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee
};

const uint8_t qr_code[] PROGMEM= {
	36,36,
	0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x7e,
	0x70,0x00,0x00,0x00,0x70,0x07,0x70,0x77,0x77,0x70,0x07,0x07,0x07,0x70,0x00,0x00,0x00,0x7e,
	0x70,0x77,0x77,0x70,0x70,0x00,0x00,0x70,0x77,0x07,0x70,0x77,0x00,0x70,0x77,0x77,0x70,0x7e,
	0x70,0x70,0x00,0x70,0x77,0x70,0x07,0x00,0x07,0x70,0x00,0x70,0x70,0x70,0x70,0x00,0x70,0x7e,
	0x70,0x70,0x00,0x70,0x70,0x70,0x07,0x77,0x77,0x70,0x07,0x70,0x77,0x70,0x70,0x00,0x70,0x7e,
	0x70,0x70,0x00,0x70,0x77,0x70,0x07,0x07,0x70,0x70,0x77,0x77,0x00,0x70,0x70,0x00,0x70,0x7e,
	0x70,0x77,0x77,0x70,0x77,0x77,0x77,0x70,0x00,0x70,0x77,0x00,0x70,0x70,0x77,0x77,0x70,0x7e,
	0x70,0x00,0x00,0x00,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x00,0x00,0x00,0x7e,
	0x77,0x77,0x77,0x77,0x70,0x77,0x70,0x77,0x00,0x00,0x07,0x77,0x00,0x77,0x77,0x77,0x77,0x7e,
	0x70,0x70,0x07,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x77,0x00,0x00,0x70,0x77,0x07,0x00,0x7e,
	0x70,0x00,0x00,0x77,0x07,0x70,0x07,0x00,0x70,0x00,0x00,0x77,0x07,0x70,0x07,0x00,0x70,0x7e,
	0x70,0x70,0x77,0x70,0x70,0x70,0x00,0x07,0x70,0x70,0x70,0x00,0x07,0x00,0x00,0x07,0x00,0x7e,
	0x77,0x00,0x07,0x77,0x07,0x07,0x00,0x77,0x70,0x07,0x77,0x77,0x77,0x07,0x07,0x07,0x07,0x7e,
	0x77,0x70,0x00,0x70,0x07,0x07,0x70,0x70,0x70,0x77,0x77,0x70,0x00,0x07,0x70,0x07,0x77,0x7e,
	0x70,0x00,0x77,0x77,0x00,0x70,0x77,0x70,0x77,0x07,0x70,0x07,0x77,0x77,0x07,0x77,0x07,0x7e,
	0x77,0x77,0x70,0x00,0x70,0x70,0x77,0x00,0x77,0x77,0x00,0x07,0x77,0x70,0x00,0x07,0x77,0x7e,
	0x77,0x00,0x77,0x77,0x00,0x00,0x70,0x07,0x07,0x77,0x00,0x07,0x70,0x00,0x07,0x00,0x77,0x7e,
	0x77,0x00,0x07,0x00,0x00,0x70,0x77,0x00,0x77,0x70,0x00,0x00,0x77,0x00,0x70,0x70,0x77,0x7e,
	0x77,0x70,0x70,0x77,0x00,0x77,0x00,0x77,0x07,0x77,0x70,0x00,0x00,0x00,0x70,0x07,0x70,0x7e,
	0x70,0x77,0x00,0x00,0x07,0x00,0x77,0x77,0x00,0x70,0x70,0x77,0x70,0x07,0x00,0x70,0x07,0x7e,
	0x77,0x07,0x07,0x77,0x00,0x00,0x70,0x77,0x77,0x00,0x07,0x70,0x00,0x00,0x70,0x77,0x00,0x7e,
	0x70,0x00,0x70,0x70,0x70,0x70,0x77,0x70,0x70,0x77,0x77,0x07,0x70,0x77,0x77,0x00,0x77,0x7e,
	0x70,0x07,0x00,0x77,0x77,0x00,0x77,0x07,0x00,0x77,0x00,0x07,0x07,0x77,0x77,0x70,0x70,0x7e,
	0x77,0x70,0x70,0x00,0x00,0x00,0x70,0x00,0x07,0x77,0x70,0x07,0x00,0x00,0x70,0x00,0x00,0x7e,
	0x77,0x07,0x70,0x07,0x00,0x77,0x70,0x70,0x07,0x70,0x00,0x77,0x00,0x70,0x70,0x07,0x70,0x7e,
	0x70,0x77,0x77,0x00,0x77,0x70,0x70,0x70,0x77,0x07,0x77,0x70,0x00,0x00,0x00,0x70,0x77,0x7e,
	0x77,0x77,0x77,0x77,0x70,0x70,0x77,0x00,0x00,0x77,0x00,0x07,0x70,0x77,0x70,0x07,0x07,0x7e,
	0x70,0x00,0x00,0x00,0x70,0x00,0x77,0x70,0x70,0x00,0x00,0x70,0x00,0x70,0x70,0x77,0x77,0x7e,
	0x70,0x77,0x77,0x70,0x70,0x07,0x07,0x07,0x77,0x00,0x70,0x00,0x00,0x77,0x70,0x00,0x00,0x7e,
	0x70,0x70,0x00,0x70,0x77,0x00,0x77,0x70,0x70,0x00,0x07,0x00,0x00,0x00,0x00,0x70,0x70,0x7e,
	0x70,0x70,0x00,0x70,0x70,0x70,0x00,0x77,0x70,0x07,0x70,0x07,0x07,0x77,0x07,0x77,0x70,0x7e,
	0x70,0x70,0x00,0x70,0x70,0x07,0x00,0x07,0x00,0x00,0x77,0x70,0x77,0x70,0x07,0x07,0x77,0x7e,
	0x70,0x77,0x77,0x70,0x77,0x70,0x70,0x77,0x77,0x00,0x77,0x70,0x00,0x70,0x00,0x77,0x70,0x7e,
	0x70,0x00,0x00,0x00,0x70,0x77,0x77,0x00,0x77,0x00,0x07,0x07,0x07,0x00,0x70,0x00,0x77,0x7e,
	0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x7e,
	0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,

};

const uint8_t supercratebox_logo[] PROGMEM= {
    50,43,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x08,0x88,0x88,0x88,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x88,0x88,0x88,0x80,0x08,0x88,0x88,0x88,0x80,0x08,0x88,0x88,0x88,0x80,
    0x08,0x88,0x88,0x88,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x88,0x88,0x88,0x80,0x08,0x88,0x88,0x88,0x80,0x08,0x88,0x88,0x88,0x80,
    0x08,0x80,0x00,0x00,0x00,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x00,0x00,0x08,0x80,0x00,0x08,0x80,
    0x08,0x80,0x00,0x00,0x00,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x00,0x00,0x08,0x80,0x00,0x08,0x80,
    0x08,0x88,0x88,0x88,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x88,0x88,0x88,0x80,0x08,0x88,0x88,0x80,0x00,0x08,0x88,0x88,0x80,0x00,
    0x08,0x88,0x88,0x88,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x88,0x88,0x88,0x80,0x08,0x88,0x88,0x80,0x00,0x08,0x88,0x88,0x80,0x00,
    0x00,0x00,0x00,0x02,0x20,0x02,0x20,0x00,0x02,0x20,0x02,0x20,0x00,0x00,0x00,0x02,0x20,0x00,0x00,0x00,0x02,0x20,0x00,0x02,0x20,
    0x00,0x00,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x00,0x00,0x08,0x80,0x00,0x00,0x00,0x08,0x80,0x00,0x08,0x80,
    0x02,0x22,0x22,0x22,0x20,0x02,0x22,0x22,0x22,0x20,0x02,0x20,0x00,0x00,0x00,0x02,0x22,0x22,0x22,0x20,0x02,0x20,0x00,0x02,0x20,
    0x02,0x22,0x22,0x22,0x20,0x02,0x22,0x22,0x22,0x20,0x02,0x20,0x00,0x00,0x00,0x02,0x22,0x22,0x22,0x20,0x02,0x20,0x00,0x02,0x20,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x0a,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xa0,
    0x0a,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xa0,
    0x0a,0xa0,0x00,0x00,0x00,0x0a,0xa0,0x00,0x0a,0xa0,0x0a,0xa0,0x00,0x0a,0xa0,0x00,0x00,0xaa,0x00,0x00,0x0a,0xa0,0x00,0x00,0x00,
    0x0a,0xa0,0x00,0x00,0x00,0x0a,0xa0,0x00,0x0a,0xa0,0x0a,0xa0,0x00,0x0a,0xa0,0x00,0x00,0xaa,0x00,0x00,0x0a,0xa0,0x00,0x00,0x00,
    0x0a,0xa0,0x00,0x00,0x00,0x0a,0xaa,0xaa,0xa0,0x00,0x0a,0xaa,0xaa,0xaa,0xa0,0x00,0x00,0xaa,0x00,0x00,0x0a,0xaa,0xaa,0xa0,0x0e,
    0x0a,0xa0,0x00,0x00,0x00,0x0a,0xaa,0xaa,0xa0,0x00,0x0a,0xaa,0xaa,0xaa,0xa0,0x00,0x00,0xaa,0x00,0x00,0x0a,0xaa,0xaa,0xa0,0xee,
    0x09,0x90,0x00,0x00,0x00,0x09,0x90,0x00,0x09,0x90,0x09,0x90,0x00,0x09,0x90,0x00,0x00,0x99,0x00,0x00,0x09,0x90,0x00,0x0e,0xee,
    0x0a,0xa0,0x00,0x00,0x00,0x0a,0xa0,0x00,0x0a,0xa0,0x0a,0xa0,0x00,0x0a,0xa0,0x00,0x00,0xaa,0x00,0x00,0x0a,0xa0,0x00,0x00,0x00,
    0x09,0x99,0x99,0x99,0x90,0x09,0x90,0x00,0x09,0x90,0x09,0x90,0x00,0x09,0x90,0x00,0x00,0x99,0x00,0x00,0x09,0x99,0x99,0x99,0x90,
    0x09,0x99,0x99,0x99,0x90,0x09,0x90,0x00,0x09,0x90,0x09,0x90,0x00,0x09,0x90,0x00,0x00,0x99,0x00,0x00,0x09,0x99,0x99,0x99,0x90,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,
    0xee,0x00,0x00,0x00,0x00,0x08,0x88,0x88,0x88,0x80,0x08,0x88,0x88,0x88,0x80,0x08,0x80,0x00,0x08,0x80,0x00,0x00,0x00,0x00,0xee,
    0xee,0xe0,0x00,0x00,0x00,0x08,0x88,0x88,0x88,0x80,0x08,0x88,0x88,0x88,0x80,0x08,0x80,0x00,0x08,0x80,0x00,0x00,0x00,0x0e,0xee,
    0xee,0xee,0x00,0x00,0x00,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x00,0x00,0x00,0xee,0xee,
    0xee,0xee,0xe0,0x00,0x00,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x00,0x00,0x0e,0xee,0xee,
    0xee,0xee,0xee,0x00,0x00,0x08,0x88,0x88,0x80,0x00,0x08,0x80,0x00,0x08,0x80,0x00,0x08,0x88,0x80,0x00,0x00,0x00,0xee,0xee,0xee,
    0xee,0xee,0xee,0xe0,0x00,0x08,0x88,0x88,0x80,0x00,0x08,0x80,0x00,0x08,0x80,0x00,0x08,0x88,0x80,0x00,0x00,0x0e,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0x00,0x02,0x20,0x00,0x02,0x20,0x02,0x20,0x00,0x02,0x20,0x02,0x20,0x00,0x02,0x20,0x00,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xe0,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x08,0x80,0x00,0x08,0x80,0x0e,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0x02,0x22,0x22,0x22,0x20,0x02,0x22,0x22,0x22,0x20,0x02,0x20,0x00,0x02,0x20,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0x02,0x22,0x22,0x22,0x20,0x02,0x22,0x22,0x22,0x20,0x02,0x20,0x00,0x02,0x20,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0x00,0x00,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
};

const uint8_t supercratebox_logo_half[] PROGMEM= {
	26,22,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x08,0x88,0x80,0x80,0x08,0x08,0x88,0x80,0x88,0x88,0x08,0x88,0x80,
	0x08,0x00,0x00,0x80,0x08,0x08,0x00,0x80,0x80,0x00,0x08,0x00,0x80,
	0x08,0x88,0x80,0x80,0x08,0x08,0x88,0x80,0x88,0x80,0x08,0x88,0x00,
	0x00,0x00,0x20,0x20,0x02,0x02,0x00,0x00,0x20,0x00,0x02,0x00,0x20,
	0x02,0x22,0x20,0x22,0x22,0x02,0x00,0x00,0x22,0x22,0x02,0x00,0x20,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0a,0xaa,0xa0,0xaa,0xaa,0x0a,0xaa,0xa0,0xaa,0xaa,0x0a,0xaa,0xa0,
	0x0a,0x00,0x00,0xa0,0x0a,0x0a,0x00,0xa0,0x0a,0xa0,0x0a,0x00,0x00,
	0x0a,0x00,0x00,0xaa,0xa0,0x0a,0xaa,0xa0,0x0a,0xa0,0x0a,0xaa,0x0e,
	0x09,0x00,0x00,0x90,0x09,0x09,0x00,0x90,0x09,0x90,0x09,0x00,0x00,
	0x09,0x99,0x90,0x90,0x09,0x09,0x00,0x90,0x09,0x90,0x09,0x99,0x90,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xe0,0x00,0x00,0x88,0x88,0x08,0x88,0x80,0x80,0x08,0x00,0x00,0x0e,
	0xee,0x00,0x00,0x80,0x08,0x08,0x00,0x80,0x80,0x08,0x00,0x00,0xee,
	0xee,0xe0,0x00,0x88,0x80,0x08,0x00,0x80,0x08,0x80,0x00,0x0e,0xee,
	0xee,0xee,0x00,0x20,0x02,0x02,0x00,0x20,0x20,0x02,0x00,0xee,0xee,
	0xee,0xee,0xe0,0x22,0x22,0x02,0x22,0x20,0x20,0x02,0x0e,0xee,0xee,
	0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xee,0xee,0xee,
	0xee,0xee,0xee,0xe0,0x00,0x00,0x00,0x00,0x00,0x0e,0xee,0xee,0xee,
	0xee,0xee,0xee,0xee,0xe0,0x00,0x00,0x00,0x0e,0xee,0xee,0xee,0xee,
	0xee,0xee,0xee,0xee,0xee,0xe0,0x00,0x0e,0xee,0xee,0xee,0xee,0xee,
};

const uint8_t pokitto_logo[] PROGMEM = {
	44,13,
	0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0x00,0x0e,0xe0,0x00,0x0e,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
	0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x0b,0xb2,0x0e,0xe0,0xbb,0x0e,0x00,0x00,0x00,0x00,0xee,0xee,0xee,0xee,0xee,
	0xee,0x00,0x00,0x0e,0x00,0x00,0x00,0x0b,0xb2,0x0e,0xe0,0xbb,0x00,0x0b,0xb0,0x0b,0xb0,0xee,0xe0,0x00,0x0e,0xee,
	0x00,0xbb,0xbb,0x00,0x0b,0xbb,0xb0,0x0b,0xb2,0x00,0x00,0x00,0x00,0x0b,0xb0,0x0b,0xb0,0x00,0x0b,0xbb,0xb0,0xee,
	0x0b,0x0b,0xbb,0xb0,0x0b,0xbb,0xbb,0x2b,0xbb,0xbb,0xb0,0xbb,0x2b,0x0b,0xbb,0x0b,0xbb,0xb2,0x0b,0xbb,0xbb,0x0e,
	0x0b,0xb2,0x2b,0xb0,0xb0,0x00,0xbb,0x2b,0xbb,0xbb,0xb0,0xbb,0x2b,0xb0,0xbb,0xb0,0xbb,0xb2,0xb0,0x00,0xbb,0x20,
	0x0b,0xb2,0x0b,0xb0,0xbb,0x00,0xbb,0x20,0xbb,0x22,0x20,0xbb,0x20,0x0b,0x02,0x2b,0x02,0x20,0xbb,0x00,0xbb,0x20,
	0x0b,0xbb,0xb0,0x20,0xbb,0x00,0xbb,0x2b,0x0b,0xb0,0x00,0xbb,0x20,0x0b,0xb2,0x0b,0xb2,0x00,0xbb,0x00,0xbb,0x20,
	0x0b,0xbb,0xb2,0x00,0xbb,0x00,0xbb,0x2b,0xb2,0xb0,0xe0,0xbb,0x20,0x0b,0xb2,0x0b,0xb2,0x00,0xbb,0x00,0xbb,0x20,
	0x0b,0xb2,0x20,0xee,0x0b,0xbb,0x0b,0x2b,0xb2,0xbb,0x00,0xbb,0x20,0x0b,0xb2,0x0b,0xb2,0x0e,0x0b,0xbb,0x0b,0x20,
	0x0b,0xb2,0x0e,0xee,0xe0,0xbb,0xb2,0x0b,0xb2,0x2b,0xb0,0xbb,0x20,0x0b,0xb2,0x0b,0xb2,0x0e,0xe0,0xbb,0xb2,0x0e,
	0x0b,0x20,0xee,0xee,0xe0,0x22,0x00,0x02,0x20,0x02,0x20,0x22,0x0e,0x02,0x20,0x02,0x20,0x0e,0xe0,0x22,0x20,0xee,
	0xe0,0x0e,0xee,0xee,0xee,0x00,0xee,0x00,0x0e,0xe0,0x00,0x00,0xee,0xe0,0x00,0x00,0x00,0xee,0xee,0x00,0x0e,0xee,
};

const uint8_t pokitto[] PROGMEM = {
    14,15,
    0xee,0x33,0x33,0x33,0x33,0x33,0xee,
    0xee,0x3b,0x33,0x33,0x33,0xb3,0xee,
    0xee,0x33,0x00,0x00,0x00,0x33,0xee,
    0x33,0x33,0x07,0x00,0x70,0x33,0x33,
    0x3e,0x33,0x00,0x00,0x00,0x33,0xe3,
    0x33,0x33,0x00,0x77,0x00,0x33,0x33,
    0xee,0x33,0x00,0x00,0x00,0x33,0xee,
    0xee,0x33,0x33,0x33,0x33,0x33,0xee,
    0xee,0x33,0xa3,0x33,0x33,0xa3,0xee,
    0xee,0x3a,0xaa,0x33,0xa3,0x33,0xee,
    0xee,0x33,0xa3,0x33,0x33,0x33,0xee,
    0xee,0x3b,0x33,0xaa,0x33,0xb3,0xee,
    0xee,0x33,0x33,0x33,0x33,0x33,0xee,
    0xee,0x3e,0x3e,0xee,0xe3,0xe3,0xee,
    0xee,0x33,0x3e,0xee,0xe3,0x33,0xee,
};

const uint8_t pokitto_player [] PROGMEM = {
	34,40,
	0xee,0xee,0xee,0xee,0xee,0xee,0xe0,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
	0xee,0xee,0xee,0xee,0xee,0xee,0x00,0x0e,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
	0xee,0xee,0xee,0xee,0xee,0xe0,0x00,0x00,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
	0xee,0xee,0xee,0xee,0xee,0xe0,0x00,0x00,0x0e,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
	0xee,0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x0e,0xee,0xee,0x00,0x00,0x00,0x00,0xee,
	0xee,0xee,0xee,0xee,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xee,
	0xee,0xee,0xee,0xee,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,
	0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,
	0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xee,0xee,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
	0xee,0xee,0xee,0xe0,0x0f,0xff,0x00,0x02,0x22,0x00,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,
	0xee,0xee,0xee,0xe0,0xff,0xf0,0x00,0x24,0x44,0x2f,0xff,0x00,0xff,0xf0,0x00,0x00,0x00,
	0xee,0xee,0xee,0xe0,0xff,0x0f,0xf2,0x44,0x44,0x2f,0xf0,0xff,0x0f,0xf0,0x00,0x00,0x00,
	0xee,0xee,0xee,0xe0,0xff,0xf7,0x02,0x44,0x44,0x2f,0xff,0x70,0xff,0xf0,0x00,0x09,0x90,
	0xee,0xee,0xee,0xe0,0xff,0xf0,0x02,0x44,0x44,0x2f,0xff,0x00,0xff,0xf0,0x00,0x99,0x90,
	0xee,0xee,0xee,0x04,0xff,0xf0,0x02,0x44,0x44,0x2f,0xff,0x00,0xff,0xf0,0x00,0x99,0x94,
	0xee,0xee,0xe0,0x04,0xff,0xff,0xf2,0x44,0x44,0x2f,0xff,0xff,0xff,0xf0,0x00,0x99,0x94,
	0xee,0xee,0xe0,0x0f,0xff,0xff,0xf2,0x44,0x44,0x2f,0xff,0xff,0xff,0xf0,0x00,0x99,0x94,
	0xee,0xee,0xee,0x4f,0xff,0xff,0xff,0x24,0x44,0x2f,0xff,0xff,0xff,0xf0,0x00,0x99,0x94,
	0xee,0xee,0xee,0x4f,0xff,0xff,0xff,0xf2,0x22,0xff,0xff,0xff,0xf0,0x00,0x00,0x99,0x94,
	0xee,0xee,0xee,0x4f,0xff,0xff,0x99,0x9f,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x99,0x94,
	0xee,0xee,0xee,0x4f,0x9f,0xff,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xf0,0x0f,0x99,0x94,
	0xee,0xee,0xee,0x4f,0x4f,0xbb,0xbb,0xbb,0xbf,0xff,0xff,0xff,0xff,0x4f,0xff,0x99,0x94,
	0xee,0xee,0xee,0x4f,0x4f,0xb3,0xbb,0xb3,0xbf,0xff,0xff,0xff,0xf4,0xff,0xff,0x99,0x94,
	0xee,0xee,0xee,0x4f,0x94,0xb0,0xbb,0xbb,0xb4,0x4f,0xff,0xff,0x4f,0xff,0x4f,0x99,0x4e,
	0xee,0xe4,0x44,0xf4,0xf9,0x4b,0xbb,0x7b,0xb4,0xf4,0xff,0xf4,0xff,0xf4,0xff,0x99,0x4e,
	0xee,0x4f,0xff,0xf4,0xff,0xf4,0xbb,0x74,0x4f,0xf4,0x44,0x4f,0xff,0x4f,0xff,0x99,0x4e,
	0xe4,0xff,0xff,0xf4,0x4f,0x4b,0xbb,0xb4,0xff,0xf9,0x99,0xff,0xf4,0xff,0xf9,0x99,0x4e,
	0x4f,0xff,0xff,0x4f,0xf4,0xbb,0xbb,0xbb,0x4f,0xf9,0x9f,0x44,0x44,0xff,0xf9,0x99,0x4e,
	0x4f,0xff,0xf9,0x4f,0xff,0xb3,0xbb,0xb3,0xb4,0x44,0x4f,0xff,0xff,0x4f,0xf9,0x94,0xee,
	0x4f,0xff,0x99,0x4f,0xff,0xbb,0xbb,0xbb,0xbf,0xff,0x4f,0xff,0xff,0x9f,0x99,0x94,0xee,
	0xe4,0x99,0x99,0x44,0xff,0xfb,0xff,0xfb,0xff,0xff,0x4f,0xff,0xff,0x99,0x99,0x94,0xee,
	0xee,0x49,0x99,0x44,0x4f,0xff,0xff,0xff,0xff,0xff,0x49,0xff,0xf9,0x99,0x94,0x4e,0xee,
	0xee,0xef,0xf9,0x4e,0xe4,0x4f,0xff,0xff,0xff,0xff,0x44,0x99,0x99,0x44,0x4e,0xee,0xee,
	0xee,0x4f,0xf4,0xee,0xee,0x44,0x44,0x44,0x44,0x44,0xe4,0x49,0x99,0x4e,0xee,0xee,0xee,
	0xee,0x44,0x4e,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x44,0xf4,0xee,0xee,0xee,0xee,
	0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x4f,0x4e,0xee,0xee,0xee,0xee
};

const uint8_t supercratebox_play_off[] PROGMEM = {
    34,10,
    0x00,0x00,0x00,0x00,0x00,0x00,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x77,0x77,0x70,0x07,0x70,0xee,0xee,0x07,0x77,0x77,0x70,0x07,0x77,0x00,0x77,0x70,
    0x07,0x77,0x77,0x70,0x07,0x70,0xee,0xee,0x07,0x77,0x77,0x70,0x07,0x77,0x00,0x77,0x70,
    0x07,0x70,0x07,0x70,0x07,0x70,0xee,0xee,0x07,0x70,0x07,0x70,0x07,0x77,0x00,0x77,0x70,
    0x07,0x77,0x77,0x70,0x07,0x70,0xee,0xee,0x07,0x77,0x77,0x70,0x00,0x07,0x77,0x70,0x00,
    0x06,0x66,0x66,0x60,0x06,0x60,0xee,0xee,0x06,0x66,0x66,0x60,0xee,0x06,0x66,0x60,0xee,
    0x07,0x70,0x00,0x0e,0x07,0x70,0x00,0x00,0x07,0x70,0x07,0x70,0xee,0xe0,0x77,0x0e,0xee,
    0x06,0x60,0xee,0xee,0x06,0x66,0x66,0x60,0x06,0x60,0x06,0x60,0xee,0xe0,0x66,0x0e,0xee,
    0x06,0x60,0xee,0xee,0x06,0x66,0x66,0x60,0x06,0x60,0x06,0x60,0xee,0xe0,0x66,0x0e,0xee,
    0x00,0x00,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xee,0xe0,0x00,0x0e,0xee,
};
const uint8_t supercratebox_play_on[] PROGMEM = {
    34,10,
    0x00,0x00,0x00,0x00,0x00,0x00,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x0a,0xaa,0xaa,0xa0,0x0a,0xa0,0xee,0xee,0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0x00,0xaa,0xa0,
    0x0a,0xaa,0xaa,0xa0,0x0a,0xa0,0xee,0xee,0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0x00,0xaa,0xa0,
    0x0a,0xa0,0x0a,0xa0,0x0a,0xa0,0xee,0xee,0x0a,0xa0,0x0a,0xa0,0x0a,0xaa,0x00,0xaa,0xa0,
    0x0a,0xaa,0xaa,0xa0,0x0a,0xa0,0xee,0xee,0x0a,0xaa,0xaa,0xa0,0x00,0x0a,0xaa,0xa0,0x00,
    0x09,0x99,0x99,0x90,0x09,0x90,0xee,0xee,0x09,0x99,0x99,0x90,0xee,0x09,0x99,0x90,0xee,
    0x0a,0xa0,0x00,0x0e,0x0a,0xa0,0x00,0x00,0x0a,0xa0,0x0a,0xa0,0xee,0xe0,0xaa,0x0e,0xee,
    0x09,0x90,0xee,0xee,0x09,0x99,0x99,0x90,0x09,0x90,0x09,0x90,0xee,0xe0,0x99,0x0e,0xee,
    0x09,0x90,0xee,0xee,0x09,0x99,0x99,0x90,0x09,0x90,0x09,0x90,0xee,0xe0,0x99,0x0e,0xee,
    0x00,0x00,0xee,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xee,0xe0,0x00,0x0e,0xee,
};

const uint8_t supercratebox_credits_off[] PROGMEM = {
    58,10,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,
    0x07,0x77,0x77,0x70,0x07,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x0e,0xe0,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x0e,
    0x07,0x77,0x77,0x70,0x07,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x00,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x0e,
    0x07,0x70,0x00,0x00,0x07,0x70,0x00,0x77,0x00,0x77,0x00,0x00,0x00,0x77,0x00,0x77,0x00,0x00,0x77,0x00,0xe0,0x00,0x77,0x00,0x00,0x77,0x00,0x00,0x0e,
    0x07,0x70,0xee,0xee,0x07,0x77,0x77,0x77,0x00,0x77,0x77,0x0e,0xe0,0x77,0x00,0x77,0x0e,0xe0,0x77,0x0e,0xee,0xe0,0x77,0x0e,0xe0,0x77,0x77,0x77,0x0e,
    0x06,0x60,0xee,0xee,0x06,0x66,0x66,0x00,0x00,0x66,0x66,0x0e,0xe0,0x66,0x00,0x66,0x0e,0xe0,0x66,0x0e,0xee,0xe0,0x66,0x0e,0xe0,0x66,0x66,0x66,0x0e,
    0x07,0x70,0x00,0x00,0x07,0x70,0x00,0x77,0x00,0x77,0x00,0x00,0x00,0x77,0x00,0x77,0x00,0x00,0x77,0x00,0x0e,0xe0,0x77,0x0e,0xe0,0x00,0x00,0x77,0x0e,
    0x06,0x66,0x66,0x60,0x06,0x60,0x00,0x66,0x00,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x66,0x66,0x66,0x0e,0xe0,0x66,0x0e,0xe0,0x66,0x66,0x66,0x0e,
    0x06,0x66,0x66,0x60,0x06,0x60,0xe0,0x66,0x00,0x66,0x66,0x66,0x00,0x66,0x66,0x0e,0xe0,0x66,0x66,0x66,0x0e,0xe0,0x66,0x0e,0xe0,0x66,0x66,0x66,0x0e,
    0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xe0,0x00,0x00,0x00,0x0e,0xe0,0x00,0x0e,0xe0,0x00,0x00,0x00,0x0e,
};
const uint8_t supercratebox_credits_on[] PROGMEM = {
    58,10,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,
    0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0x0e,0xe0,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0xaa,0x0e,
    0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0x00,0x00,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0xaa,0x0e,
    0x0a,0xa0,0x00,0x00,0x0a,0xa0,0x00,0xaa,0x00,0xaa,0x00,0x00,0x00,0xaa,0x00,0xaa,0x00,0x00,0xaa,0x00,0x00,0x00,0xaa,0x00,0x00,0xaa,0x00,0x00,0x0e,
    0x0a,0xa0,0xee,0xee,0x0a,0xaa,0xaa,0xaa,0x00,0xaa,0xaa,0x0e,0xe0,0xaa,0x00,0xaa,0x0e,0xe0,0xaa,0x0e,0xee,0xe0,0xaa,0x0e,0xe0,0xaa,0xaa,0xaa,0x0e,
    0x09,0x90,0xee,0xee,0x09,0x99,0x99,0x00,0x00,0x99,0x99,0x0e,0xe0,0x99,0x00,0x99,0x0e,0xe0,0x99,0x0e,0xee,0xe0,0x99,0x0e,0xe0,0x99,0x99,0x99,0x0e,
    0x0a,0xa0,0x00,0x00,0x0a,0xa0,0x00,0xaa,0x00,0xaa,0x00,0x00,0x00,0xaa,0x00,0xaa,0x00,0x00,0xaa,0x00,0x0e,0xe0,0xaa,0x0e,0xe0,0x00,0x00,0xaa,0x0e,
    0x09,0x99,0x99,0x90,0x09,0x90,0x00,0x99,0x00,0x99,0x99,0x99,0x00,0x99,0x99,0x00,0x00,0x99,0x99,0x99,0x0e,0xe0,0x99,0x0e,0xe0,0x99,0x99,0x99,0x0e,
    0x09,0x99,0x99,0x90,0x09,0x90,0xe0,0x99,0x00,0x99,0x99,0x99,0x00,0x99,0x99,0x0e,0xe0,0x99,0x99,0x99,0x0e,0xe0,0x99,0x0e,0xe0,0x99,0x99,0x99,0x0e,
    0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xe0,0x00,0x00,0x00,0x0e,0xe0,0x00,0x0e,0xe0,0x00,0x00,0x00,0x0e,
};

//Weapons and bullets subtypes
#define NUMWEAPONS 13
#define W_PISTOL 0
#define W_RIFLE 1
#define W_SHOTGUN 2
#define W_ROCKET 3
#define W_CLUB 4
#define W_REVOLVER 5
#define W_MINE 6
#define W_SNIPER 7
#define W_MACHINEGUN 8
#define W_GRENADE 9
#define W_AKIMBO 10
#define W_DISK 11
#define W_LASER 12
//can't be held by the player as a weapon :
#define W_EXPLOSION 13
#define W_SHELL 14

//uint8_t unlockedWeapons = 12;
//uint8_t unlockedMaps = 4;

#define SCORETHRESHOLD_1 4
#define SCORETHRESHOLD_2 8
#define SCORETHRESHOLD_3 12
#define SCORETHRESHOLD_4 14
#define SCORETHRESHOLD_5 16
const uint8_t scoreThresholds[] = {SCORETHRESHOLD_1, SCORETHRESHOLD_2, SCORETHRESHOLD_3, SCORETHRESHOLD_4, SCORETHRESHOLD_5};

//Enemy types
#define E_SMALL 0
#define E_BIG 1

//there is a scale between the world cccordinates and the screen coordinates
//to allow sub pixel accuracy without the use of floats
#define SCALE 8

int cameraX, cameraY, shakeTimeLeft, shakeAmplitude;
uint8_t _popupTimeLeft;
const char* _popupText;

int toScreenX(int x) {
  return x / SCALE - cameraX;
}

int toScreenY(int y) {
  return y / SCALE - cameraY;
}

///////////////////////////////////////////// SOUNDS
/*
const uint8_t player_damage_sound[] PROGMEM = {0x00, 0x45, 0x5, 0x64, 0x00, 0x00};
const uint8_t revolver_sound[] PROGMEM = {0x00, 0x45, 0x70, 0x49, 0x1, 0x7C, 0x78, 0x4D, 0x4, 0x2C, 0x00, 0x00};
const uint8_t grenade_sound[] PROGMEM = {0x00, 0x45, 0x01, 0x2C, 0x00, 0x00};
const uint8_t machinegun_sound[] PROGMEM = {0x00, 0x45, 0x1, 0x40, 0x81, 0x41, 0x78, 0x49, 0x78, 0x8D, 0x5, 0x2C, 0x00, 0x00};
const uint8_t rocket_sound[] PROGMEM = {0x80, 0x45, 0x80, 0x01, 0x88, 0x89, 0x3C, 0x5C, 0x00, 0x00};
const uint8_t blast_sound[] PROGMEM = {0x00, 0x45, 0x78, 0x49, 0x78, 0x4D, 0xA, 0x28, 0x00, 0x00};
const uint8_t power_up_sound[] PROGMEM = {0x00, 0x05, 0x1, 0x40, 0x1, 0x50, 0x1, 0x5C, 0x1, 0x70, 0x1, 0x80, 0x1, 0x6C, 0x1, 0x54, 0x1, 0x60, 0x1, 0x74, 0x1, 0x84, 0x1, 0x4C, 0x1, 0x5C, 0x1, 0x68, 0x1, 0x7C, 0x1, 0x8C, 0x00, 0x00};
const uint8_t enemy_death_sound[] PROGMEM = {0x00, 0x45, 0x1, 0x84, 0x00, 0x00};
const uint8_t jump_sound[] PROGMEM = {0x00, 0x05, 0x70, 0x49, 0x88, 0x4D, 0x3, 0x54, 0x00, 0x00};
const uint8_t enemy_felt_sound[] PROGMEM = {0x80, 0x05, 0x80, 0x01, 0x88, 0x49, 0xF, 0x20, 0x00, 0x00};
const uint8_t shotgun_sound[] PROGMEM = {0x00, 0x45, 0x70, 0x49, 0x3, 0x34, 0x00, 0x00};
const uint8_t laser_sound[] PROGMEM = {0x00, 0x05, 0x78, 0x4D, 0x78, 0x49, 0x6, 0x70, 0x00, 0x00};
const uint8_t club_sound[] PROGMEM = {0x80, 0x05, 0x78, 0x4D, 0x78, 0x49, 0x3, 0x18, 0x00, 0x00};
*/

//const uint8_t ok_sound[] PROGMEM = { 1, 110, -6, 11, 126, 2, 0, 150, -25, -3, 47, 3};
const uint8_t cancel_sound[] PROGMEM = { 1, 120, 3, 8, 126, 2, 0, 130, -13, 10, 169, 3};
const uint8_t tick_sound[] PROGMEM = { 0, 196, -35, -3, 142, 1};


///////////////////////////////////////////// WORLD
#define SPRITE_SIZE 6

//#define BG_BLOCK 1
//#define BG_FENCE 2
//#define BG_TREE 3
//#define BG_BLOCKTOP 4
//#define BG_BLOCKCORNER 5
//#define BG_TREEMIDDLE 6
//#define BG_TREEBOTTOM 7

//maps are encoded like bitmaps
const uint8_t map0[] PROGMEM = {
  16, 10,
  B11111110, B01111111,
  B10000000, B00000001,
  B10000000, B00000001,
  B10001111, B11110001,
  B10000000, B00000001,
  B10000000, B00000001,
  B11111100, B00111111,
  B10000000, B00000001,
  B10000000, B00000001,
  B10011111, B11111001,
};
/*
const uint8_t map1[] PROGMEM = {
  24, 16,
  B11111111, B11100111, B11111111,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10000011, B11111111, B11000001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B11111100, B00000000, B00111111,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10000111, B11111111, B11100001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B11111000, B00000000, B00011111,
  B11111111, B11000011, B11111111,
};
*/

const uint8_t map1[] PROGMEM = {
  18, 14,
  B11111111, B00111111, B11111111,
  B10000000, B00000000, B01111111,
  B10000000, B00000000, B01111111,
  B10000011, B11110000, B01111111,
  B10000000, B00000000, B01111111,
  B10000000, B00000000, B01111111,
  B11110000, B00000011, B11111111,
  B10000000, B00000000, B01111111,
  B10000000, B00000000, B01111111,
  B10000011, B11110000, B01111111,
  B10000000, B00000000, B01111111,
  B10000000, B00000000, B01111111,
  B11110000, B00000011, B11111111,
  B11111110, B00011111, B11111111,
};

const uint8_t map2[] PROGMEM = {
  24, 16,
  B11111111, B11100111, B11111111,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10000000, B00111100, B00000001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10000111, B11100111, B11100001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B11111100, B00011000, B00111111,
  B11100000, B00000000, B00000111,
  B11100000, B00000000, B00000111,
  B11100000, B11111111, B00000111,
  B11100000, B00000000, B00000111,
  B11100000, B00000000, B00000111,
  B11111111, B11000011, B11111111,
};

const uint8_t map3[] PROGMEM = {
  24, 16,
  B11111111, B11100111, B11111111,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10000011, B11111111, B11000001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B11111000, B00000000, B00011111,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B10001111, B11000011, B11110001,
  B10000000, B00000000, B00000001,
  B10000000, B00000000, B00000001,
  B11110000, B00111100, B00001111,
  B11110011, B11111111, B11001111,
  B11110011, B11111111, B11001111,
};

const uint8_t map4[] PROGMEM = {
  32, 24,
  B11111111, B11111110, B01111111, B11111111,
  B10000000, B00000000, B00000000, B00000001,
  B10000000, B00000000, B00000000, B00000001,
  B11110000, B00000111, B11100000, B00001111,
  B10000000, B00000000, B00000000, B00000001,
  B10000000, B00000000, B00000000, B00000001,
  B10000111, B11111100, B00111111, B11100001,
  B10000000, B00000000, B00000000, B00000001,
  B10000000, B00000000, B00000000, B00000001,
  B11110000, B00000011, B11000000, B00000001,
  B10000000, B00000011, B11000001, B11111111,
  B10000000, B00000011, B11000000, B00111111,
  B10001111, B11111111, B11000000, B00000011,
  B10000000, B00000011, B11111100, B00000011,
  B10000000, B00000000, B00000000, B00000011,
  B11111100, B00000000, B00000000, B00000011,
  B11000000, B00001100, B00000001, B11111111,
  B11000000, B00001100, B00000000, B00111111,
  B11001111, B11111100, B00000011, B00001111,
  B11000000, B00001111, B00000011, B00001111,
  B11000000, B00000011, B11000000, B00001111,
  B11111100, B00000000, B00000000, B00001111,
  B11111111, B11000000, B00000000, B00001111,
  B11111111, B11111111, B11111111, B00001111,
};

#define NUMMAPS 5
const uint8_t* const maps[NUMMAPS] = {
  map0, map1, map2, map3, map4
};

//unsigned int score[NUMMAPS];


class SuperCrateBoxSave : public Pokitto::Cookie {

public:
  uint32_t score[NUMMAPS];
  uint8_t unlockedWeapons;
  uint8_t unlockedMaps;

  SuperCrateBoxSave() {
    unlockedMaps=0;
    unlockedWeapons=0;
    for (int i=0;i<NUMMAPS;i++)
        score[i]=0;
  }
};

SuperCrateBoxSave scbSave;

const uint8_t bricks[] PROGMEM ={
    6,6,
    0x25,0x22,0x52,
    0x88,0x58,0x85,
    0x22,0x52,0x25,
    0x58,0x85,0x88,
    0x52,0x25,0x22,
    0x85,0x88,0x58
};

const uint8_t grass[] PROGMEM ={
    6,6,
    0x33,0x3b,0x33,
    0x3b,0x43,0x3b,
    0x34,0x4b,0x44,
    0x44,0x44,0x44,
    0x45,0x44,0x44,
    0x44,0x44,0x54
};

const uint8_t grass_edge[] PROGMEM ={
    6,6,
    0x33,0x3b,0x00,
    0x3b,0x43,0x30,
    0x34,0x4b,0x43,
    0x44,0x44,0x43,
    0x45,0x44,0x43,
    0x44,0x44,0x43
};
const uint8_t beam[] PROGMEM ={
    6,6,
    0x88,0x88,0x88,
    0x02,0x82,0x00,
    0x28,0x28,0x20,
    0x82,0x02,0x82,
    0x20,0x00,0x28,
    0x88,0x88,0x88
};
const uint8_t beam_edge[] PROGMEM ={
    6,6,
    0x88,0x88,0x22,
    0x02,0x82,0x00,
    0x28,0x28,0x20,
    0x82,0x02,0x82,
    0x20,0x00,0x28,
    0x88,0x88,0x88
};
const uint8_t roundPlatform[] PROGMEM ={
    6,6,
    0x55,0x55,0x55,
    0x45,0x44,0x54,
    0x44,0x44,0x44,
    0x44,0x45,0x44,
    0x44,0x44,0x44,
    0x44,0x64,0x44
};
const uint8_t roundPlatform_edge[] PROGMEM ={
    6,6,
    0x55,0x55,0x00,
    0x45,0x44,0x50,
    0x44,0x44,0x45,
    0x44,0x44,0x45,
    0x45,0x44,0x45,
    0x44,0x44,0x45
};
const uint8_t largeChecker[] PROGMEM ={
    6,6,
    0xff,0xff,0xff,
    0xf4,0xf4,0xf4,
    0x44,0x44,0x44,
    0x4f,0x44,0x4f,
    0x44,0x44,0x64,
    0x46,0x44,0x64
};
const uint8_t blackWall[] PROGMEM ={
    6,6,
    0x44,0x44,0x44,
    0x44,0x44,0x64,
    0x4f,0x44,0x44,
    0x44,0x49,0x44,
    0x44,0x44,0x44,
    0x44,0x44,0x44
};

const uint8_t bluewall[] PROGMEM ={
    6,6,
    0xcc,0xcc,0xcc,
    0xcc,0xcc,0xcc,
    0xcc,0xdd,0xcc,
    0xcc,0xdd,0xcc,
    0xcc,0xcc,0xcc,
    0xcc,0xcc,0xcc,
};

const uint8_t blueplatform[] PROGMEM ={
    6,6,
    0x11,0x11,0x11,
    0xcc,0xcc,0xcc,
    0xdd,0xdd,0xdd,
    0xdd,0xdd,0xdd,
    0xcc,0xcc,0xcc,
    0x11,0x11,0x11,
};

const uint8_t blueplatform_edge[] PROGMEM ={
    6,6,
    0x11,0x11,0x11,
    0xcc,0xcc,0xc1,
    0xcc,0xdd,0xc1,
    0xcc,0xdd,0xc1,
    0xcc,0xcc,0x10,
    0x11,0x11,0x00,
};

const uint8_t fire[][20] PROGMEM={
{
  6,6,
  0x00,0x00,0x00,
  0x00,0x90,0x90,
  0x09,0x09,0x99,
  0x09,0x99,0xa9,
  0x9a,0x9a,0xaa,
  0xa7,0xaa,0x7a
},
{
  6,6,
  0x90,0x00,0x00,
  0x09,0x09,0x09,
  0x09,0x99,0x09,
  0x9a,0xa9,0x99,
  0xa7,0xaa,0xaa,
  0xa7,0xa7,0xa7
},
{
  6,6,
  0x00,0x00,0x00,
  0x09,0x09,0x00,
  0x00,0x09,0x90,
  0x90,0x99,0xa9,
  0x99,0x9a,0xa9,
  0xaa,0xa7,0xaa
}
};

int cloudX[7]={-64,-30,0,25,50,80,100};
int cloudS[7]={30,25,15,18,12,15,28};

class World {
  public:
    const byte* tiles;
    const byte* wall; //pointer to the used tilemap
    const byte* platform;
    const byte* edge;
    byte mapNumber;

    int getWidth() {
      return SPRITE_SIZE * pgm_read_byte(tiles) * SCALE;
    }
    int getHeight() {
      return SPRITE_SIZE * pgm_read_byte(tiles + 1) * SCALE;
    }

    byte tileAtPosition(int x, int y) {
      int tile_x = (x - SCALE / 2) / SPRITE_SIZE / SCALE;
      int tile_y = (y - SCALE / 2) / SPRITE_SIZE / SCALE;

      int w = pgm_read_byte(tiles);
      int h = pgm_read_byte(tiles + 1);

      // Offmap is made of air
      if (tile_x < 0 || tile_x >= w || tile_y < 0 || tile_y >= h)
        return 0;

      //maps are encoded like bitmaps so we can use getBitmapPixel
      return getBitmapPixel(tiles, tile_x, tile_y) > 0 ? 1 : 0;
    }

    bool solidCollisionAtPosition(int x, int y, int w, int h) {
      if (tileAtPosition(x, y + h))
        return true;
      if (tileAtPosition(x + w, y + h))
        return true;
      if (tileAtPosition(x + w, y))
        return true;
      if (tileAtPosition(x, y))
        return true;
      //also check at half the length for boxes larger than a sprite
      if (w > SPRITE_SIZE * SCALE) {
        if (tileAtPosition(x + w / 2, y))
          return true;
        if (tileAtPosition(x + w / 2, y + h))
          return true;
      }
      if (h > SPRITE_SIZE * SCALE) {
        if (tileAtPosition(x, y + h / 2))
          return true;
        if (tileAtPosition(x + w, y + h / 2))
          return true;
      }
      //check all the points
      /*if((w > SPRITE_SIZE*SCALE) || (h > SPRITE_SIZE*SCALE)){
       for (int i = x; i <= (x + w); i += SPRITE_SIZE*SCALE){
       for (int j = y; j <= (y + h); j += SPRITE_SIZE*SCALE){
       if (tileAtPosition(i, j))
       return true;
       }
       }
       }*/
      return false;
    }

    void draw() {

        if(mapNumber < 2 || mapNumber==4)
        {
          #ifdef POKITTO

            pb.display.setColor(BLUE);
            pb.display.fillRect(-cameraX,-cameraY,getWidth()/ SCALE,getHeight()/ SCALE);

            pb.display.setColor(WHITE);
            int Y=getHeight()/ SCALE/2;
            pb.display.fillRect(-cameraX,Y-cameraY,getWidth()/ SCALE,getHeight()/ SCALE-Y);
            for(int i=0;i < 7;i++){
                pb.display.fillCircle(cloudX[i]-cameraX,Y-cameraY,cloudS[i]);
                cloudX[i]++;
                if(cloudX[i] > getWidth()/ SCALE+64)
                    cloudX[i]=-64;
            }

            pb.display.setColor(INDIGO);
            pb.display.fillRect(10-cameraX,18-cameraY ,25,getHeight()/ SCALE-18);
            pb.display.fillRect(40-cameraX,55-cameraY ,10,getHeight()/ SCALE-55);
            pb.display.fillRect(55-cameraX,35-cameraY ,30,getHeight()/ SCALE-35);
            if( getWidth()/SCALE > 105)
                pb.display.fillRect(90-cameraX,25-cameraY ,15,getHeight()/ SCALE-25);
            if( getWidth()/SCALE > 130)
                pb.display.fillRect(110-cameraX,40-cameraY ,20,getHeight()/ SCALE-40);

          #else
            pb.display.fillRect(-cameraX,-cameraY,getWidth()/ SCALE,getHeight()/ SCALE,BLUE);
            int Y=getHeight()/ SCALE/2;
            pb.display.fillRect(-cameraX,Y-cameraY,getWidth()/ SCALE,getHeight()/ SCALE-Y,WHITE);
            for(int i=0;i < 7;i++){
                pb.display.fillCircle(cloudX[i]-cameraX,Y-cameraY,cloudS[i],WHITE);
                cloudX[i]++;
                if(cloudX[i] > getWidth()/ SCALE+64)
                    cloudX[i]=-64;
            }

            pb.display.fillRect(10-cameraX,18-cameraY ,25,getHeight()/ SCALE-18,INDIGO);
            pb.display.fillRect(40-cameraX,55-cameraY ,10,getHeight()/ SCALE-55,INDIGO);
            pb.display.fillRect(55-cameraX,35-cameraY ,30,getHeight()/ SCALE-35,INDIGO);
            if( getWidth()/SCALE > 105)
                pb.display.fillRect(90-cameraX,25-cameraY ,15,getHeight()/ SCALE-25,INDIGO);
            if( getWidth()/SCALE > 130)
                pb.display.fillRect(110-cameraX,40-cameraY ,20,getHeight()/ SCALE-40,INDIGO);
          #endif
         }
         if(mapNumber==2)
         {
         #ifdef POKITTO

            pb.display.setColor(INDIGO);
            pb.display.fillRect(-cameraX,-cameraY,getWidth()/ SCALE,getHeight()/ SCALE);

            pb.display.setColor(DARK_GRAY);
            pb.display.fillRect(-cameraX,getWidth()/ SCALE/2-10-cameraY ,getWidth()/SCALE,getWidth()/ SCALE/2+10);
            pb.display.fillRect(10-cameraX,10-cameraY ,10,10);
            pb.display.fillRect(getWidth()/SCALE-20-cameraX,10-cameraY ,10,10);

            pb.display.setColor(INDIGO);
            pb.display.fillRect(11-cameraX,11-cameraY ,8,8);
            pb.display.fillRect(getWidth()/SCALE-19-cameraX,11-cameraY ,8,8);

          #else
            pb.display.fillRect(-cameraX,-cameraY,getWidth()/ SCALE,getHeight()/ SCALE,INDIGO);

            pb.display.fillRect(-cameraX,getWidth()/ SCALE/2-10-cameraY ,getWidth()/SCALE,getWidth()/ SCALE/2+10,DARK_GRAY);
            pb.display.fillRect(10-cameraX,10-cameraY ,10,10,DARK_GRAY);
            pb.display.fillRect(getWidth()/SCALE-20-cameraX,10-cameraY ,10,10,DARK_GRAY);

            pb.display.fillRect(11-cameraX,11-cameraY ,8,8,INDIGO);
            pb.display.fillRect(getWidth()/SCALE-19-cameraX,11-cameraY ,8,8,INDIGO);
          #endif
         }
         if(mapNumber==3)
         {
         #ifdef POKITTO
            pb.display.setColor(PEACH);
            pb.display.fillRect(-cameraX,-cameraY,getWidth()/ SCALE,getHeight()/ SCALE);

            pb.display.setColor(DARK_GRAY);
            pb.display.fillTriangle(getWidth()/SCALE/2-cameraX,-20-cameraY,20-cameraX,getHeight()/ SCALE-cameraY,getWidth()/SCALE-20-cameraX,getHeight()/ SCALE-cameraY);

          #else
            pb.display.fillRect(-cameraX,-cameraY,getWidth()/ SCALE,getHeight()/ SCALE,PEACH);

            pb.display.fillTriangle(getWidth()/SCALE/2-cameraX,-20-cameraY,20-cameraX,getHeight()/ SCALE-cameraY,getWidth()/SCALE-20-cameraX,getHeight()/ SCALE-cameraY,DARK_GRAY);
          #endif
         }

         #ifdef POKITTO
         if(getWidth()/SCALE < _LCDWIDTH)
            {
                pb.display.setColor(BLACK);
                pb.display.fillRect(0,0,-cameraX,LCDHEIGHT);
                pb.display.fillRect(getWidth()/SCALE-cameraX,0,LCDWIDTH-getWidth()/SCALE,LCDHEIGHT);
            }
          if(getHeight()/SCALE < _LCDHEIGHT)
            {
                pb.display.setColor(BLACK);
                pb.display.fillRect(0,0,LCDWIDTH,-cameraY);
                pb.display.fillRect(0,getHeight()/SCALE-cameraY,LCDWIDTH,LCDHEIGHT-getHeight()/SCALE);
            }
         #else
         if(getWidth()/SCALE < _LCDWIDTH )
            {
                pb.display.fillRect(0,0,-cameraX,LCDHEIGHT,BLACK);
                pb.display.fillRect(getWidth()/SCALE-cameraX,0,LCDWIDTH-getWidth()/SCALE-cameraX,LCDHEIGHT,BLACK);

            }
            if(getHeight()/SCALE < _LCDHEIGHT)
            {
                pb.display.fillRect(0,0,LCDWIDTH,-cameraY,BLACK);
                pb.display.fillRect(0,getHeight()/SCALE-cameraY,LCDWIDTH,LCDHEIGHT-getHeight()/SCALE-cameraY,BLACK);
            }
         #endif // POKITTO
      int xMin = cameraX / SPRITE_SIZE;
      int xMax = (_LCDWIDTH / SPRITE_SIZE) + (cameraX / SPRITE_SIZE) + 2;
      int yMin = cameraY / SPRITE_SIZE;
      int yMax = (_LCDHEIGHT / SPRITE_SIZE) + (cameraY / SPRITE_SIZE) + 2;
      int w = pgm_read_byte(tiles);
      int h = pgm_read_byte(tiles + 1);

      for (int y = yMin; y < yMax; y++) {
        for (int x = xMin; x < xMax; x++ ) {
          if (x < 0 || x >= w || y < 0 || y >= h)
            continue;
          if (getBitmapPixel(tiles, x, y)) {
            uint8_t tileNumber = 1; //platform by default
            int8_t flip = NOFLIP;

            const uint8_t* bitmap = platform;
            if (y >= getHeight() / SPRITE_SIZE / SCALE - 1 || y <= 0 || getBitmapPixel(tiles, x, y - 1)) {
              bitmap = wall; //bricks
            }
            else {
              if (edge) {
                if (y > 0 && !getBitmapPixel(tiles, x + 1, y)) {
                  bitmap = edge; //platform corner
                }
                if (y > 0 && !getBitmapPixel(tiles, x - 1, y)) {
                  bitmap = edge; //platform corner
                  flip = FLIPH;
                }
              }
            }
            #ifdef POKITTO
                pb.display.setInvisibleColor(0);
                pb.display.drawBitmap(x * SPRITE_SIZE - cameraX , y * SPRITE_SIZE - cameraY, bitmap, NOROT, flip);
            #else
                pb.display.setTransparentColor(0);
                pb.display.drawBitmapRot(x * SPRITE_SIZE - cameraX , y * SPRITE_SIZE - cameraY, bitmap, NOROT, flip);
            #endif // POKITTO
          }else {
            if (y == (getHeight() / SPRITE_SIZE / SCALE - 1)) { //bottom line
            #ifdef POKITTO
                pb.display.setInvisibleColor(0);
                pb.display.drawBitmap(x * SPRITE_SIZE - cameraX, y * SPRITE_SIZE  - cameraY,fire[(pb.frameCount%12)/4] );
            #else
                pb.display.drawBitmap(x * SPRITE_SIZE - cameraX, y * SPRITE_SIZE  - cameraY,fire[(pb.frameCount%12)/4] );
            #endif // POKITTO

            }
          }
        }
      }
    }

    void chooseMap() {
      int thisMap = mapNumber;
      while (1) {
        if (pb.update()) {

          PD::update();
          ESP.wdtFeed();
          //assign the selected map
          tiles = maps[thisMap];
          mapNumber = thisMap;
          uint8_t mapColor=GREEN;

          switch (thisMap) {
            case 1:
              wall = bricks;
              platform = beam;
              edge = beam_edge;
              mapColor=RED;
              break;

            case 2:
              wall = bluewall;
              platform = blueplatform;
              edge = blueplatform_edge;
              mapColor=BLUE;
              break;
            case 0:
            case 4:
              wall = bricks;
              platform = grass;
              edge = grass_edge;
              break;
            case 3:
              wall = blackWall;
              platform = roundPlatform;
              edge = roundPlatform_edge;
              mapColor=BROWN;
              break;

          }
          pb.display.fillScreen(LIGHT_GRAY);
          pb.display.cursorY = _LCDHEIGHT - 25;
          #ifdef POKITTO
            pb.display.setInvisibleColor(PINK);
          #endif // POKITTO
          print_border(28,16,"\21 Select map \20",WHITE,BLACK);

          char bst[12];
          sprintf(bst,"BEST: %d",scbSave.score[thisMap]);
          if (thisMap > scbSave.unlockedMaps) {
              print_border(40,_LCDHEIGHT-22,bst,LIGHT_GRAY,BLACK);
          }else{
              print_border(40,_LCDHEIGHT-22,bst,WHITE,BLACK);
          }


          //draw the map centered on the screen
          #ifdef POKITTO
             drawBitmapMono(_LCDWIDTH / 2 - getWidth() / 2 / SCALE / SPRITE_SIZE-1, _LCDHEIGHT / 2 - getHeight() / 2 / SCALE / SPRITE_SIZE - 5, mapColor, maps[thisMap]);
          #else
             pb.display.drawBitmapMono(_LCDWIDTH / 2 - getWidth() / 2 / SCALE / SPRITE_SIZE, _LCDHEIGHT / 2 - getHeight() / 2 / SCALE / SPRITE_SIZE - 5, mapColor, maps[thisMap]);
          #endif // POKITTO


          for (byte x = SPRITE_SIZE; x < _LCDWIDTH - SPRITE_SIZE; x += SPRITE_SIZE) {

            #ifdef POKITTO
               pb.display.setInvisibleColor(0);
               pb.display.drawBitmap(x, 0, platform);
            #else
               pb.display.drawBitmap(x, 0, platform);
            #endif // POKITTO

          }
          for (byte y = SPRITE_SIZE; y < _LCDHEIGHT; y += SPRITE_SIZE) {
            #ifdef POKITTO
                pb.display.setInvisibleColor(0);
                pb.display.drawBitmap(0, y, wall);
                pb.display.drawBitmap(_LCDWIDTH - SPRITE_SIZE, y, wall);
            #else
              pb.display.drawBitmap(0, y, wall);
              pb.display.drawBitmap(_LCDWIDTH - SPRITE_SIZE, y, wall);
            #endif
          }
          if (edge) { //draw the ends with the according bitmap
            #ifdef POKITTO
                pb.display.setInvisibleColor(0);
                pb.display.drawBitmap(0, 0, edge, NOROT, FLIPH);
                pb.display.drawBitmap(_LCDWIDTH - SPRITE_SIZE , 0, edge);
            #else
                pb.display.drawBitmap(0, 0, edge, NOROT, FLIPH);
                pb.display.drawBitmap(_LCDWIDTH - SPRITE_SIZE , 0, edge);
            #endif // POKITTO

          }
          else { //draw with end with a regular platform if there is no edge bitmap
            #ifdef POKITTO
                pb.display.setInvisibleColor(0);
                pb.display.drawBitmap(0, 0,  platform);
                pb.display.drawBitmap(_LCDWIDTH - SPRITE_SIZE - 2, 0, platform);
            #else
                pb.display.drawBitmap(0, 0, platform);
                pb.display.drawBitmap(_LCDWIDTH - SPRITE_SIZE, 0, platform);
            #endif // POKITTO
          }
          if (thisMap == scbSave.unlockedMaps) {
            for (byte i = 0; i < sizeof(scoreThresholds); i++) {
              if (scbSave.score[thisMap] < scoreThresholds[i]) {
                if ((pb.frameCount % 10) > 3) { //make it blink !

                  char unl_txt[20];
                  sprintf(unl_txt,"Next unlock: %d",(int)scoreThresholds[i]);
                  print_border(27,_LCDHEIGHT-10,unl_txt,WHITE,RED);
                }
                break;
              }
            }
          }
          if (thisMap > scbSave.unlockedMaps) {
            if ((pb.frameCount % 10) > 3) { //make it blink !

              #ifdef POKITTO
                pb.display.setColor(BLACK);
                pb.display.fillRect(_LCDWIDTH/2-15, _LCDHEIGHT/2-7, 28, 7);
                pb.display.setColor(WHITE,BLACK);
              #else
                pb.display.fillRect(_LCDWIDTH/2-15, _LCDHEIGHT/2-7, 28, 7,BLACK);
                pb.display.setTextColor(WHITE,BLACK);
              #endif // POKITTO


              pb.display.cursorY = _LCDHEIGHT/2-6;
              printCentered("LOCKED!");
            }
          }
          if (pb.buttons.pressed(BTN_A) && (thisMap <= scbSave.unlockedMaps)) {
            initGame();
            return;
          }
          if (pb.buttons.pressed(BTN_RIGHT))
          {
              thisMap = (thisMap + 1) % NUMMAPS;
              ////pb.sound.playOK();
              Audio::play(ok_sound);
          }
          if (pb.buttons.pressed(BTN_LEFT))
          {
              thisMap = (thisMap - 1 + NUMMAPS) % NUMMAPS;
              ////pb.sound.playOK();
              Audio::play(ok_sound);
          }
          if (pb.buttons.pressed(BTN_C) || pb.buttons.pressed(BTN_B)) {
            mainMenu();
            Audio::stop<0>();
            ////pb.sound.playOK();
            Audio::play(ok_sound);
          }
        }
        //#ifdef PICOBOY
        //yield();
        ESP.wdtFeed();
        //#endif // PICOBOY
      }
    }

    bool addScore(unsigned int newScore) {
      if (newScore > scbSave.score[mapNumber]) {
        scbSave.score[mapNumber] = newScore;
        return true;
      }
      return false;
    }
};

World world;

/////////////////////////////////////////////
///////////////////////////////////////////// BOX
/////////////////////////////////////////////

class Box {
  public:
    int x, y, vx, vy;
    int8_t dir;
    virtual byte getType() {
      return 0;
    };
    virtual int getWidth() {
      return 128;
    };
    virtual int getHeight() {
      return 128;
    };
    virtual int getGravity() {
      return 8;
    };
    virtual int getMaxSpeed() {
      return 128;
    }
    virtual int getXFriction() {
      return 5;
    }
    virtual int getYFriction() {
      return 5;
    }
    virtual int getXBounce() {
      return 100;
    }
    virtual int getYBounce() {
      return 100;
    }

    byte update() {
      vy += getGravity();
      vx = (vx * (100 - getXFriction())) / 100;
      vy = (vy * (100 - getYFriction())) / 100;
      vx = constrain(vx, - getMaxSpeed(), getMaxSpeed());
      vy = constrain(vy, - getMaxSpeed(), getMaxSpeed());
      byte collided = 0;

      x += vx;
      if (getXBounce() >= 0) {
        int8_t vxdir = vx > 0 ? 1 : -1;

        if (world.solidCollisionAtPosition(x, y, getWidth(), getHeight())) {
          collided = 1;
          do {
            x -= vxdir; //move back step by step until we get out of the colision
          }
          while (world.solidCollisionAtPosition(x, y, getWidth(), getHeight()));
          vx = -(vx * getXBounce()) / 100;
        }
      }

      y += vy;
      if (getXBounce() >= 0) {
        int8_t vydir = vy > 0 ? 1 : -1;
        if (world.solidCollisionAtPosition(x, y, getWidth(), getHeight())) {
          collided = 1;
          do {
            y -= vydir;
          }
          while (world.solidCollisionAtPosition(x, y, getWidth(), getHeight()));
          vy = -(vy * getYBounce()) / 100;
        }
      }

      if (vx > 0) {
        dir = 1;
      }
      if (vx < 0) {
        dir = -1;
      }

      return collided;
    }

    bool isOffScreen() {
      return (toScreenX(x) + toScreenX(x + getWidth()) < 0) || (toScreenX(x) > _LCDWIDTH) || (toScreenY(y) + toScreenY(y + getHeight()) < 0) || (toScreenY(y) > _LCDHEIGHT);
    }

    void draw() {
      if (isOffScreen())
        return; //skip boxes which are out of the screen
        #ifdef POKITTO
            pb.display.setColor(WHITE);
            pb.display.fillRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE);
            pb.display.setColor(BLACK);
            pb.display.drawRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE);
        #else
            pb.display.fillRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE,WHITE);
            pb.display.drawRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE,BLACK);
        #endif // POKITTO

    }
};

/////////////////////////////////////////////
///////////////////////////////////////////// BULLETS
/////////////////////////////////////////////

class Bullet :
  public Box {
  public:
    byte subtype;
    char timeLeft;

    int getWidth() {
      switch (subtype) {
        case W_CLUB :
          return 96;
        case W_PISTOL :
        case W_AKIMBO :
        case W_RIFLE :
        case W_SHOTGUN :
          return constrain(abs(vx), 8, 16);
        case W_MACHINEGUN :
          return constrain(abs(vx), 8, 24);
        case W_REVOLVER :
        case W_SNIPER :
          return constrain(abs(vx), 8, 32);
        case W_DISK :
          return min(timeLeft * 8, 48);
        case W_LASER :
          return 96;
        case W_GRENADE :
          return 24;
        case W_ROCKET :
          return 48;
        case W_MINE :
          return 32;
        case W_EXPLOSION :
          return 256;
        case W_SHELL :
          return 16;
        default :
          return 32;
      }
    };
    int getHeight() {
      switch (subtype) {
        case W_CLUB :
          return 16;
        case W_REVOLVER :
          return max(getWidth() / 2, 8);
        case W_SNIPER :
        case W_SHELL :
        case W_LASER :
          return 8;
        case W_DISK :
        case W_MINE :
          return 16;
        case W_ROCKET :
          return 24;
        default :
          return getWidth();
          break;
      }
    };
    int getGravity() {
      switch (subtype) {
        case W_GRENADE :
        case W_MINE :
        case W_SHELL :
          return 5;
        case W_CLUB :
        case W_DISK :
        case W_LASER :
        case W_ROCKET :
        case W_EXPLOSION :
          return 0;
        default:
          return abs(vx) > 16 ? 0 : 2;
      }
    };
    int getMaxSpeed() {
      return 128;
    }
    virtual int getXFriction() {
      switch (subtype) {
        case W_SHOTGUN :
          return 10;
        case W_CLUB :
        case W_DISK :
        case W_LASER :
          return 0;
        case W_ROCKET :
          return -20; //negative value so it accelerates
        case W_EXPLOSION :
          return 100;
        default :
          return Box::getXFriction();
      }
    }
    int getXBounce() {
      switch (subtype) {
        case W_DISK :
          return 100;
        case W_CLUB :
        case W_EXPLOSION :
        case W_LASER :
          return -1; //don't collide the world
        case W_GRENADE :
        case W_SHELL :
          return 80;
        case W_ROCKET :
          return 0;
        default :
          return 30;
      }
    };
    int getYBounce() {
      if ((subtype == W_GRENADE) || (subtype == W_SHELL))
        return getXBounce();
      else
        return 0;
    };

    int getDamage() {
      switch (subtype) {
          return 1;
        case W_REVOLVER :
        case W_CLUB :
          return 2;
        case W_SNIPER :
        case W_DISK :
        case W_EXPLOSION :
        case W_LASER :
          return 10;
        case W_GRENADE :
        case W_ROCKET :
        case W_MINE :
        case W_SHELL :
          return 0;
        default :
          return 1;
      }
    }

    int getMaxTimeLeft() {
      switch (subtype) {
        case W_CLUB :
          return 2;
        case W_SHELL :
          return 20;
        case W_MINE :
        case W_DISK :
          return 100;
        case W_EXPLOSION :
          return 5;
        case W_GRENADE :
        case W_ROCKET :
          return 40;
        default :
          return 25;
      }

    }

    bool explodes() {
      switch (subtype) {
        case W_GRENADE :
        case W_ROCKET :
        case W_MINE :
          return true;
        default:
          return false;
      }
    }

    bool destroyOnWorldContact() {
      return (subtype == W_ROCKET) ? true : false;
    }

    bool destroyOnEnemyContact() {
      switch (subtype) {
        case W_CLUB :
        case W_DISK :
        case W_LASER :
        case W_EXPLOSION :
        case W_SHELL :
          return false;
        default:
          return true;
      }
    }

    bool damagePlayer() {
      return (subtype == W_DISK) ? true : false;
    }

    void update() {
      if (timeLeft) {
        byte collided = Box::update();
        timeLeft--;
        if (destroyOnWorldContact() && collided == 1) {
          timeLeft = 0;
        }
        if ((timeLeft == 0) && explodes()) {
          subtype = W_EXPLOSION;
          x -= getWidth() / 2; //offset the explosion for it to be centered
          y -= getHeight() / 2;
          timeLeft = 8;
          //set the camera shake
          shakeTimeLeft = 10;
          shakeAmplitude = 2;
          ////pb.sound.playPattern(blast_sound, 0);
          Audio::play<2>(blast_sound);
        }
      }
    }

    void draw() {
      if (timeLeft) {

        #ifdef POKITTO
            pb.display.setInvisibleColor(PINK);
            pb.display.setColor(ORANGE);
            if (subtype == W_ROCKET || subtype==W_MINE)
                pb.display.setColor(LIGHT_GRAY);
            if (subtype == W_GRENADE )
                pb.display.setColor(GREEN);
            if (subtype== W_EXPLOSION){
                pb.display.setColor(((timeLeft%8)/2 < 2)?WHITE:BLACK);
                pb.display.fillCircle(toScreenX(x)+getWidth() / SCALE/2, toScreenY(y)+ getHeight() / SCALE/2,getWidth() / SCALE/2);
                return;
            }

            if (subtype == W_LASER) {
                pb.display.fillRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE);
                return;
            }
            if (subtype == W_CLUB) {
                pb.display.setColor(LIGHT_GRAY);
                pb.display.fillRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE);
                return;
            }
            pb.display.fillRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE);
            pb.display.setColor(BLACK);
            pb.display.drawRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE);
        #else
            pb.display.setTransparentColor(PINK);
            int color=ORANGE;
            if (subtype == W_GRENADE || subtype == W_ROCKET || subtype==W_MINE)
                color=LIGHT_GRAY;
            if (subtype== W_EXPLOSION){
                pb.display.fillCircle(toScreenX(x)+getWidth() / SCALE/2, toScreenY(y)+ getHeight() / SCALE/2,getWidth() / SCALE/2,((timeLeft%4)/2==0)?BLACK:WHITE);
                return;
            }

            if (subtype == W_LASER) {
                pb.display.fillRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE,color);
                return;
            }
            if (subtype == W_CLUB) {
                pb.display.fillRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE,LIGHT_GRAY);
                return;
            }
            pb.display.fillRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE,color);

            pb.display.drawRect(toScreenX(x), toScreenY(y), getWidth() / SCALE, getHeight() / SCALE,BLACK);
        #endif // POKITTO
      }
    }
};

#define NUMBULLETS 20
static Bullet bullets[NUMBULLETS];

/////////////////////////////////////////////
///////////////////////////////////////////// WEAPON
/////////////////////////////////////////////

const byte club[] PROGMEM = {
    24,6,
    0x76,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0x66,0x67,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xe5,0x66,0x67,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xe5,0x66,0x67,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xe5,0x66,0x6e,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xe6,0x6e,0xee,0xee,0xee,0xee,0xee,0xee,0xee
};

const byte pistol[] PROGMEM = {
    24, 3,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0x00,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe0,0x00,0x0e,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe0,0xee,0xee,0xee,0xee
};

const byte laser[] PROGMEM = {
    24,5,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x1e,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0x11,0x11,0x11,0x11,0x1e,0x6e,0x6e,0xee,
    0xee,0xee,0xee,0xee,0x1a,0xaa,0xaa,0xa1,0x16,0x66,0x69,0xee,
    0xee,0xee,0xee,0xee,0x11,0x11,0x11,0x11,0x1e,0x6e,0x6e,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x1e,0xee,0xee,0xee
};

const byte revolver[] PROGMEM = {
    24,4,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x5e,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x66,0x66,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe4,0x66,0x66,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe4,0x55,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe4,0xee,0xee,0xee,0xee
};


const byte rifle[] PROGMEM = {
    24,4,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe5,0xee,
    0xee,0xee,0xee,0xee,0xee,0x6e,0xee,0xe6,0x64,0x46,0x66,0xee,
    0xee,0xee,0xee,0xee,0xee,0x44,0xe6,0x66,0x44,0x46,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0x44,0xe4,0xe5,0xee,0xee,0xee,0xee
};


const byte sniper[] PROGMEM = {
    24,4,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x00,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0x96,0xee,0xe6,0x66,0x66,0x00,0x66,0x0e,
    0xee,0xee,0xee,0xee,0x96,0x65,0x66,0x55,0x99,0x00,0xee,0xee,
    0xee,0xee,0xee,0xee,0x99,0x9e,0xee,0x55,0xee,0xee,0xee,0xee
};


const byte shotgun[] PROGMEM = {
    24,4,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe5,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0x66,0x66,0x66,0xee,0xee,
    0xee,0xee,0xee,0xee,0xe4,0x46,0x66,0x64,0x44,0x66,0xee,0xee,
    0xee,0xee,0xee,0xee,0xe4,0x45,0x56,0xee,0xee,0xee,0xee,0xee
};

const byte machinegun[] PROGMEM = {
    24,5,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe5,0xee,0xee,
    0xee,0xee,0xee,0xee,0xee,0xee,0xe6,0x66,0x66,0x66,0xee,0xee,
    0xee,0xee,0xee,0xee,0x44,0xee,0xe6,0x66,0x66,0x66,0xee,0xee,
    0xee,0xee,0xee,0xee,0x44,0xee,0xe6,0x65,0x55,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0x44,0x46,0x66,0xe5,0x55,0xee,0xee,0xee
};

const byte disk[] PROGMEM = {
    24,5,
    0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe5,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0x3b,0xbe,0xe5,0x66,0x65,0x55,0xee,0xee,
    0xee,0xee,0xee,0xee,0x33,0x35,0x65,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0x33,0x35,0x65,0xee,0xee,0xee,0xee,0xee,
    0xee,0xee,0xee,0xee,0x55,0xb2,0xe5,0x66,0x65,0x55,0xee,0xee
};

const byte rocket[] PROGMEM = {
    24,5,
    0xee,0xee,0xee,0xe3,0xee,0xee,0xee,0xee,0xee,0x3e,0xee,0xee,
    0xee,0xee,0xee,0xeb,0x33,0x33,0x33,0x33,0x33,0xbe,0xee,0xee,
    0xee,0xee,0xee,0xe3,0x3e,0x3e,0x33,0x33,0x33,0x3e,0xee,0xee,
    0xee,0xee,0xee,0xe3,0x33,0x33,0x33,0x33,0x33,0x3e,0xee,0xee,
    0xee,0xee,0xee,0xe3,0xee,0xee,0xee,0xee,0xee,0x3e,0xee,0xee
};

const byte grenade[] PROGMEM = {
    24,4,
    0xee,0xee,0xee,0xee,0xee,0x5e,0xe5,0xee,0xee,0x5e,0xee,0xee,
    0xee,0xee,0xee,0xee,0x55,0x56,0x65,0x66,0x66,0x6e,0xee,0xee,
    0xee,0xee,0xee,0xee,0x45,0x5e,0xe5,0x66,0x66,0x6e,0xee,0xee,
    0xee,0xee,0xee,0xee,0x4e,0x56,0x65,0xe4,0xee,0xee,0xee,0xee
};



class Weapon {
  public:
    byte subtype;
    byte cooldown;
    Box* shooter;

    void init() {
      cooldown = 0;
      for (byte i = 0; i < NUMBULLETS; i++) {
        bullets[i].timeLeft = 0;
      }
    }

    byte getMaxCooldown() {
      switch (subtype) {
        case W_CLUB :
          return 10;
        case W_PISTOL :
        case W_AKIMBO :
        case W_REVOLVER :
          return 0;
        case W_SNIPER :
          return 7;
        case W_SHOTGUN :
          return 11;
        case W_RIFLE :
          return 2;
        case W_MACHINEGUN :
          return 1;
        case W_DISK :
          return 19;
        case W_LASER :
          return 30;
        case W_GRENADE :
        case W_ROCKET :
        case W_MINE :
          return 19;
        case W_EXPLOSION :
        default :
          return 5;
      }
    }

    void addBullet(int x, int y, int dir, byte subtype) {
      for (byte i = 0; i < NUMBULLETS; i++) {
        if (bullets[i].timeLeft == 0) {
          bullets[i].subtype = subtype;
          bullets[i].timeLeft = bullets[i].getMaxTimeLeft();

          //screen shaking
          switch (subtype) {
            case W_SNIPER :
            case W_REVOLVER :
              shakeTimeLeft = 4;
              shakeAmplitude = 4;
            case W_MACHINEGUN :
              shakeTimeLeft = 2;
              shakeAmplitude = 1;
          }

          //initial bullet speeds
          switch (subtype) {
            case W_CLUB :
              bullets[i].vx = dir * 32;
              bullets[i].vy = shooter->vy;
              break;
            case W_MACHINEGUN :
              bullets[i].vx = (dir * 48) + random(-8, 9);
              bullets[i].vy = random(-16, 17);
              shooter->vx -= shooter->dir * 32; //player recoil
            case W_SHOTGUN :
              bullets[i].vx = (dir * 48) + random(-8, 9);
              bullets[i].vy = random(-10, 11);
              break;
            case W_DISK :
              bullets[i].vx = dir * 26;
              bullets[i].vy = 0;
              break;
            case W_LASER :
              bullets[i].vx = dir * 50;
              bullets[i].vy = 0;
              break;
            case W_GRENADE : //grenade speed depends on player's speed
              bullets[i].vx = (dir * 32) + shooter->vx / 2;
              bullets[i].vy = -32 + shooter->vy / 2;
              break;
            case W_ROCKET :
              bullets[i].vx = dir * 16;
              bullets[i].vy = 0;
              break;
            case W_MINE :
              bullets[i].vx = 0;
              bullets[i].vy = 0;
              break;
            case W_SHELL :
              bullets[i].vx = - dir * random(16, 24);
              bullets[i].vy = shooter->vy - random(16, 24);
              break;
            default :
              bullets[i].vx = (dir * 64) + random(-8, 9);
              bullets[i].vy = random(0, 11) - 5;
          }

          //bullet vertical offset
          switch (subtype) {
            case W_SHOTGUN :
            case W_LASER :
            case W_DISK :
              y += 32;
              break;
            case W_ROCKET :
              y += 16;
              break;
            default :
              y += 24;
              break;
          }

          //horizontal bullet offset
          switch (subtype) {
            case W_SHELL :
              x -= 16;
            case W_ROCKET:
            case W_CLUB :
              x -= dir * 32;
            case W_MINE :
              break;
            default :
              x += dir * 46;
          }

          if (dir > 0) {
            x += shooter->getWidth();
          }
          else {
            x -= bullets[i].getWidth();
          }

          x += shooter->vx / 2;
          bullets[i].x = x;
          bullets[i].y = y;

          break;
        }
      }
    };

    void shoot() {
      cooldown = getMaxCooldown();
      addBullet(shooter->x, shooter->y, shooter->dir, subtype);
      if (subtype == W_SHOTGUN) {
        addBullet(shooter->x, shooter->y, shooter->dir, subtype);
        addBullet(shooter->x, shooter->y, shooter->dir, subtype);
        addBullet(shooter->x, shooter->y, shooter->dir, subtype);
        addBullet(shooter->x, shooter->y, shooter->dir, subtype);
      }
      if (subtype == W_AKIMBO) {
        addBullet(shooter->x, shooter->y, -shooter->dir, subtype);
      }
      switch (subtype) { //eject a shell
        case W_RIFLE:
        case W_SNIPER:
        case W_SHOTGUN:
          addBullet(shooter->x, shooter->y, shooter->dir, W_SHELL);
      }

      switch (subtype) {
        case W_ROCKET :
          ////pb.sound.playPattern(rocket_sound, 0);
          Audio::play<2>(rocket_sound);
          break;
        case W_REVOLVER :
        case W_MACHINEGUN :
        case W_SNIPER :
          ////pb.sound.playPattern(machinegun_sound, 0);
          Audio::play<2>(machinegun_sound);
          break;
        case W_GRENADE :
        case W_DISK :
          ////pb.sound.playPattern(grenade_sound, 0);
          Audio::play<2>(grenade_sound);
          break;
        case W_SHOTGUN :
          ////pb.sound.playPattern(shotgun_sound, 0);
          Audio::play<2>(shotgun_sound);
          break;
        case W_MINE :
          break;
        case W_PISTOL :
          Audio::play(revolver_sound);
          break;       
        case W_AKIMBO :
        case W_RIFLE :
          ////pb.sound.playTick();
          Audio::play(machinegun_sound);
          break;
        case W_LASER :
          ////pb.sound.playPattern(laser_sound, 0);
           Audio::play<2>(laser_sound);
          break;
        case W_CLUB :
          ////pb.sound.playPattern(club_sound, 0);
           Audio::play<2>(club_sound);
          break;
      }
    }

    bool isAutomatic() {
      switch (subtype) {
        case W_RIFLE :
        case W_MACHINEGUN :
          return true;
        default :
          return false;
      }
    };

    void update() {
      for (byte i = 0; i < NUMBULLETS; i++) {
        bullets[i].update();
      }
      if (cooldown > 0) {
        cooldown--;
      }
      else {
        if (isAutomatic()) {
          if (pb.buttons.repeat(BTN_A, 1)) {
            shoot();
          }
        }
        else {
          if (pb.buttons.pressed(BTN_A)) {
            shoot();
          }
        }
      }
    }

    void draw() {
      int bx = toScreenX(shooter->x) - 10;
      int by = toScreenY(shooter->y)+1;
      int8_t flip = (shooter->dir > 0) ? NOFLIP : FLIPH;
      const byte* bitmap;
      const byte* bitmapWhite;
      switch (subtype) {
        case W_CLUB :
          if (cooldown > 8) {
            bitmap = 0; //don't draw the club when already in use
          }
          else {
            bitmap = club;
            bx += shooter->dir * cooldown / 2; //sliding back the club
          }
          bitmapWhite = 0;
          by -= 2;
          break;
        case W_PISTOL :
        case W_AKIMBO :
          bitmap = pistol;
          bitmapWhite = 0;
          by += 3;
          break;
        case W_REVOLVER :
          bitmap = revolver;
          bitmapWhite = 0;
          by += 2;
          break;
        case W_SNIPER :
          bitmap = sniper;
          bitmapWhite = 0;
          by += 2;
          bx -= (cooldown > 4) ? shooter->dir : 0;
          break;
        case W_RIFLE :
          bitmap = rifle;
          bitmapWhite = 0;
          by += 2;
          bx -= shooter->dir * cooldown;
          break;
        case W_SHOTGUN :
          bitmap = shotgun;
          bitmapWhite = 0;
          by += 3;
          bx -= shooter->dir * cooldown / 4;
          break;
        case W_MACHINEGUN :
          bitmap = machinegun;
          bitmapWhite = 0;
          by += 2;
          break;
        case W_DISK :
          bitmap = disk;
          bitmapWhite = 0;
          by += 2;
          break;
        case W_LASER :
          bitmap = laser;
          bitmapWhite = 0;
          by += 2;
          break;
        case W_GRENADE :
          bitmap = grenade;
          bitmapWhite = 0;
          by += 3;
          break;
        case W_ROCKET :
          bitmap = rocket;
          bitmapWhite = 0;
          by += 1;
          break;
        default :
          bitmap = 0;
          bitmapWhite = 0;
      }
      #ifdef POKITTO
            pb.display.setInvisibleColor(PINK);
      #else
            pb.display.setTransparentColor(PINK);
      #endif

      if (bitmap) { //draw the weappon
        #ifdef POKITTO
            pb.display.drawBitmap(bx, by, bitmap, NOROT, flip);
        #else
            pb.display.drawBitmapRot(bx, by, bitmap, NOROT, flip);
        #endif

      }
      if (bitmapWhite) {
          #ifdef POKITTO
            pb.display.drawBitmap(bx, by, bitmapWhite, NOROT, flip);
          #else
            pb.display.drawBitmapRot(bx, by, bitmapWhite, NOROT, flip);
          #endif // POKITTO
      }
      if (subtype == W_AKIMBO) { //draw the symetric of the pistol in the akimbo case
        if (bitmap) {
          #ifdef POKITTO
            pb.display.drawBitmap(bx, by, bitmap, NOROT, (flip + 1) % 2);
          #else
            pb.display.drawBitmapRot(bx, by, bitmap, NOROT, (flip + 1) % 2);
          #endif // POKITTO
        }
        if (bitmapWhite) {
          #ifdef POKITTO
            pb.display.drawBitmap(bx, by, bitmapWhite, NOROT, (flip + 1) % 2);
          #else
            pb.display.drawBitmapRot(bx, by, bitmapWhite, NOROT, (flip + 1) % 2);
          #endif
        }
      }
      if (subtype == W_LASER) { //reloading line on the laser
        if (shooter->dir > 0) {
            #ifdef POKITTO
                pb.display.setColor(GREEN);
                pb.display.drawFastHLine(toScreenX(shooter->x)-1, toScreenY(shooter->y) + 5, 6 - cooldown / 5);
            #else
                pb.display.drawFastHLine(toScreenX(shooter->x)-1, toScreenY(shooter->y) + 5, 6 - cooldown / 5,GREEN);
            #endif // POKITTO
        }else {
            #ifdef POKITTO
                pb.display.setColor(GREEN);
                pb.display.drawFastHLine(toScreenX(shooter->x)-1+cooldown / 5, toScreenY(shooter->y) + 5, 6 - cooldown / 5);
            #else
                pb.display.drawFastHLine(toScreenX(shooter->x)-1+cooldown / 5, toScreenY(shooter->y) + 5, 6 - cooldown / 5,GREEN);
            #endif // POKITTO
        }

      }
      if (subtype == W_DISK) { //refill animation
        if (shooter->dir > 0) {
          #ifdef POKITTO
            pb.display.setColor(ORANGE);
            pb.display.fillRect(toScreenX(shooter->x) + 5, toScreenY(shooter->y) + 5, 4 - cooldown / 4, 1);
          #else
            pb.display.fillRect(toScreenX(shooter->x) + 5, toScreenY(shooter->y) + 5, 4 - cooldown / 4, 1,ORANGE);
          #endif // POKITTO

        }
        else {
          #ifdef POKITTO
            pb.display.setColor(ORANGE);
            pb.display.fillRect(toScreenX(shooter->x) + cooldown / 4 - 5, toScreenY(shooter->y) + 5, 4, 1);
          #else
            pb.display.fillRect(toScreenX(shooter->x) + cooldown / 4 - 5, toScreenY(shooter->y) + 5, 4, 1,ORANGE);
          #endif // POKITTO

        }
      }
      if (subtype == W_MINE) { //refill animation
        if (shooter->dir > 0) {
          #ifdef POKITTO
            pb.display.setColor(LIGHT_GRAY);
            pb.display.fillRect(toScreenX(shooter->x) + 5, toScreenY(shooter->y) + 5, 4 - cooldown / 4, 1);
          #else
            pb.display.fillRect(toScreenX(shooter->x) + 5, toScreenY(shooter->y) + 5, 4 - cooldown / 4, 1,LIGHT_GRAY);
          #endif // POKITTO

        }
        else {
          #ifdef POKITTO
            pb.display.setColor(LIGHT_GRAY);
            pb.display.fillRect(toScreenX(shooter->x) + cooldown / 4 - 5, toScreenY(shooter->y) + 5, 4, 1);
          #else
            pb.display.fillRect(toScreenX(shooter->x) + cooldown / 4 - 5, toScreenY(shooter->y) + 5, 4, 1,LIGHT_GRAY);
          #endif // POKITTO

        }
      }
    }
};

/////////////////////////////////////////////
///////////////////////////////////////////// PLAYER
/////////////////////////////////////////////


const byte playerBitmap[][29] PROGMEM = {
  {6,9,
    0x70,0x77,0x00,
    0x00,0x00,0x00,
    0x04,0x44,0x40,
    0x09,0xf4,0xf0,
    0x00,0xf4,0x00,
    0x09,0xf4,0xf0,
    0x0f,0xff,0xf0,
    0x00,0x00,0x00,
    0x07,0x77,0x70
  },
  {6,9,
    0x70,0x77,0x00,
    0x00,0x00,0x00,
    0x04,0x44,0x40,
    0x09,0xff,0x40,
    0x09,0x0f,0x40,
    0x09,0xff,0x40,
    0x04,0xff,0xf0,
    0x70,0x70,0x00,
    0x77,0x77,0x07
  },
  {6,9,
    0x70,0x77,0x00,
    0x00,0x00,0x00,
    0x04,0x44,0x40,
    0x09,0xff,0x40,
    0x09,0x0f,0x40,
    0x09,0xff,0x40,
    0x04,0xff,0xf0,
    0x00,0x00,0x00,
    0x77,0x07,0x77
  },
  {6,9,
    0x70,0x77,0x00,
    0x00,0x00,0x00,
    0x04,0x44,0x40,
    0x09,0xf4,0xf0,
    0x00,0xf4,0x00,
    0x09,0xff,0xf0,
    0x44,0x9f,0xf0,
    0x00,0x00,0x40,
    0x77,0x77,0x00
  },
  //jemp
  {6,9,
    0x00,0x00,0x00,
    0x00,0x44,0x00,
    0x09,0xf4,0xf0,
    0x00,0xf4,0x00,
    0x09,0xf4,0xf0,
    0x0f,0xff,0xf0,
    0x00,0x00,0x00,
    0x00,0x77,0x00,
    0x07,0x77,0x07
  }
};


class Player :
  public Box {
  public:
    Weapon weapon;
    bool jumping;
    bool doubleJumped;
    bool dead;
    unsigned int score;

    void init() {
      x = 128;
      y = 150;
      dir = 1;
      score = 0;
      dead = false;
      weapon.init();
      weapon.shooter = this;
    }

    int getWidth() {
      return 48;
    }
    int getHeight() {
      return 72;
    }
    int getGravity() {
      return 8;
    }
    int getXFriction() {
      if (dead) {
        return 10;
      }
      else {
        return 40;
      };
    }
    int getXBounce() {
      if (dead) {
        return -1;
      }
      else {
        return 0;
      };
    }
    int getYBounce() {
      return 0;
    }

    void kill(int dir) {
      dead = true;
      vx = dir * 32;
      vy = -32;

    }

    void update() {
      if (!dead) {
        //player input
        if (pb.buttons.repeat(BTN_LEFT, 1)) {
          dir = -1;
          vx -= 16;
        }
        if (pb.buttons.repeat(BTN_RIGHT, 1)) {
          dir = 1;
          vx += 16;
        }
        if (pb.buttons.repeat(BTN_UP, 10) && (pb.buttons.timeHeld(BTN_DOWN) > 40)) {
          weapon.subtype ++;
          weapon.subtype %= NUMWEAPONS;
          score = 0;
          popup("WEAPON CHEAT");
        }

        if (y > world.getHeight()) {
          kill(dir);
        }

        //jumping
        if (world.solidCollisionAtPosition(x, y+1, getWidth(), getHeight())) {
          doubleJumped = false;
        }
        if (pb.buttons.pressed(BTN_B)||pb.buttons.pressed(BTN_UP)) {
          if (world.solidCollisionAtPosition(x, y+1, getWidth(), getHeight())) {
            vy = -32;
            jumping = true;
            ////pb.sound.playPattern(jump_sound, 1);
            Audio::play(jump_sound);
          }
          else {
            if (doubleJumped == false) {
              vy = -32;
              doubleJumped = true;
              jumping = true;
              ////pb.sound.playPattern(jump_sound, 1);
              Audio::play(jump_sound);
            }
          }
        }
        if ((pb.buttons.timeHeld(BTN_B) > 0) && (pb.buttons.timeHeld(BTN_B) < 5) && (vy < 0) && jumping) {
          if (doubleJumped) {
            vy -= 6;
          }
          else {
            vy -= 12;
          }
        }
        if ((pb.buttons.timeHeld(BTN_UP) > 0) && (pb.buttons.timeHeld(BTN_UP) < 5) && (vy < 0) && jumping) {
          if (doubleJumped) {
            vy -= 6;
          }
          else {
            vy -= 12;
          }
        }

        if (vy > 0) {
          jumping = false;
        }
      }

      weapon.update();

      int8_t d = dir;
      Box::update(); //update physics
      dir = d; //override the direction calculated by Box::update(), which depend on velocity.
      //here the direction of the player should only depend on user input
      //I know, it's not very clean to do that this way
    }

    void draw() {
      if (isOffScreen()) {
        return;
      }
      int8_t flip = (dir > 0) ? NOFLIP : FLIPH;
      byte frame = (dir * x / 32 + 255) % 5; //get the current frame from the x position. Add 255 to avoid being under 0.
      if (vx == 0) {
        frame = 0;
      }
      if (!world.solidCollisionAtPosition(x, y + 1, getWidth(), getHeight())) { //in the air
        if (vy < 0) {
          frame = 4;
        }
        else {
          frame = 1;
        }
      }
      #ifdef POKITTO
        pb.display.setInvisibleColor(WHITE);
        pb.display.drawBitmap(toScreenX(x), toScreenY(y), playerBitmap[frame], NOROT, flip);
      #else
        pb.display.setTransparentColor(WHITE);
        pb.display.drawBitmapRot(toScreenX(x), toScreenY(y), playerBitmap[frame], NOROT, flip);
      #endif // POKITTO


      weapon.draw();
    }
};

Player player;

/////////////////////////////////////////////
///////////////////////////////////////////// ENEMY
/////////////////////////////////////////////

const byte smallEnemyBitmap[][26] PROGMEM = {
  { 6, 8,
   0xee,0xee,0xee,
   0xe0,0x00,0x0e,
   0x08,0xbb,0x80,
   0x03,0xbb,0xb0,
   0x03,0x00,0xb0,
   0xe0,0x00,0x0e,
   0xe0,0xee,0x0e,
   0xe0,0xee,0x0e
  },
  { 6, 8,
   0xee,0xee,0xee,
   0xe0,0x00,0x0e,
   0x08,0xbb,0x80,
   0x03,0xbb,0xb0,
   0x03,0x00,0xb0,
   0xe0,0x00,0x0e,
   0xee,0x00,0xee,
   0xe0,0xee,0x0e
  },
  { 6, 8,
   0xe0,0x00,0x0e,
   0x08,0xbb,0x80,
   0x03,0xbb,0xb0,
   0x03,0x00,0xb0,
   0xe0,0x00,0x0e,
   0xe0,0xee,0x0e,
   0x0e,0xee,0xe0,
   0x0e,0xee,0xee
  },
  { 6, 8,
   0xee,0xee,0xee,
   0xe0,0x00,0x0e,
   0x08,0xbb,0x80,
   0x03,0xbb,0xb0,
   0x03,0x00,0xb0,
   0xe0,0x00,0x0e,
   0x00,0xee,0x0e,
   0xee,0xee,0x0e
  },
  { 6, 8,
   0xe0,0x00,0x0e,
   0x08,0xbb,0x80,
   0x03,0xbb,0xb0,
   0x03,0x00,0xb0,
   0xe0,0x00,0x0e,
   0xee,0x0e,0x0e,
   0xe0,0xee,0xe0,
   0xee,0xee,0xe0
  }
};

const byte smallEnemyAngryBitmap[][26] PROGMEM = {
  { 6, 8,
   0xee,0xee,0xee,
   0xe0,0x00,0x0e,
   0x07,0x88,0x70,
   0x02,0x88,0x80,
   0x02,0x00,0x80,
   0xe0,0x00,0x0e,
   0xe0,0xee,0x0e,
   0xe0,0xee,0x0e
  },
  { 6, 8,
   0xee,0xee,0xee,
   0xe0,0x00,0x0e,
   0x07,0x88,0x70,
   0x02,0x88,0x80,
   0x02,0x00,0x80,
   0xe0,0x00,0x0e,
   0xee,0x00,0xee,
   0xe0,0xee,0x0e
  },
  { 6, 8,
   0xe0,0x00,0x0e,
   0x07,0x88,0x70,
   0x02,0x88,0x80,
   0x02,0x00,0x80,
   0xe0,0x00,0x0e,
   0xe0,0xee,0x0e,
   0x0e,0xee,0xe0,
   0x0e,0xee,0xee
  },
  { 6, 8,
   0xee,0xee,0xee,
   0xe0,0x00,0x0e,
   0x07,0x88,0x70,
   0x02,0x88,0x80,
   0x02,0x00,0x80,
   0xe0,0x00,0x0e,
   0x00,0xee,0x0e,
   0xee,0xee,0x0e
  },
  { 6, 8,
   0xe0,0x00,0x0e,
   0x07,0x88,0x70,
   0x02,0x88,0x80,
   0x02,0x00,0x80,
   0xe0,0x00,0x0e,
   0xee,0x0e,0x0e,
   0xe0,0xee,0xe0,
   0xee,0xee,0xe0
  }
};

const byte bigEnemyBitmap[][92] PROGMEM = {
  { 10, 10,
    0xe0,0x00,0x00,0x00,0x0e,
    0x03,0x3b,0x7b,0xbb,0xb0,
    0x03,0x55,0x53,0x55,0x50,
    0x03,0xb8,0xb3,0xb8,0xb0,
    0x03,0xb8,0xb3,0xb8,0xb0,
    0xe0,0x3b,0xb0,0xbb,0xb0,
    0xe0,0x3b,0x7b,0x7b,0xb0,
    0xe0,0x30,0x00,0x00,0xb0,
    0xee,0x0e,0xee,0xee,0x0e,
    0xe0,0xee,0xee,0xe0,0xee
  },
  { 10, 10,
    0xee,0xee,0xee,0xee,0xee,
    0xe0,0x00,0x00,0x00,0x0e,
    0x03,0x33,0xbb,0x7b,0xb0,
    0x03,0x3b,0x55,0x53,0x50,
    0x03,0x3b,0xb8,0xb3,0xb0,
    0xe0,0x3b,0xb8,0xb3,0xb0,
    0xe0,0x3b,0xbb,0xb0,0xb0,
    0xe0,0x3b,0xbb,0x7b,0x70,
    0x03,0x00,0x00,0xb0,0x00,
    0x00,0xee,0xee,0x0e,0xee
  },
  { 10, 10,
    0xe0,0x00,0x00,0x00,0x0e,
    0x03,0x3b,0xb7,0xbb,0xb0,
    0x03,0xb5,0x55,0x35,0x50,
    0x03,0xbb,0x8b,0x3b,0x80,
    0x03,0xbb,0x8b,0x3b,0x80,
    0xe0,0x3b,0xbb,0xbb,0xb0,
    0xe0,0x3b,0xbb,0x0b,0xb0,
    0x03,0x3b,0xb7,0xb7,0xb0,
    0x0b,0x0e,0x0b,0x00,0x00,
    0x00,0xee,0xe0,0xee,0xee
  },
  { 10, 10,
    0xe0,0x00,0x00,0x00,0x0e,
    0x03,0x3b,0xb7,0xbb,0xb0,
    0x03,0xb5,0x55,0x35,0x50,
    0x03,0xbb,0x8b,0x3b,0x80,
    0x03,0xbb,0x8b,0x3b,0x80,
    0xe0,0x3b,0xbb,0x3b,0xb0,
    0xe0,0x3b,0xbb,0x0b,0xb0,
    0x03,0x3b,0xb7,0xb7,0xb0,
    0x30,0x0b,0x00,0x00,0x00,
    0xee,0x0b,0x0e,0xee,0x0e
  },
  { 10, 10,
    0xee,0xee,0xee,0xee,0xee,
    0xe0,0x00,0x00,0x00,0x0e,
    0x03,0x33,0xb7,0xbb,0xb0,
    0x03,0x35,0x55,0x35,0x50,
    0x03,0x3b,0x8b,0x3b,0x80,
    0xe0,0x3b,0x8b,0x0b,0x80,
    0xe0,0x3b,0xbb,0x0b,0xb0,
    0xe0,0x3b,0xb7,0xb7,0xb0,
    0xee,0x0b,0x00,0x00,0xbb,
    0xee,0x0b,0x0e,0xee,0x0b
  }
};

const byte bigEnemyAngryBitmap[][92] PROGMEM = {
  { 10, 10,
    0xe0,0x00,0x00,0x00,0x0e,
    0x02,0x28,0x78,0x88,0x80,
    0x02,0x22,0x22,0x22,0x20,
    0x02,0x87,0x82,0x87,0x80,
    0x02,0x87,0x82,0x87,0x80,
    0xe0,0x28,0x80,0x88,0x80,
    0xe0,0x28,0x78,0x78,0x80,
    0xe0,0x20,0x00,0x00,0x80,
    0xee,0x0e,0xee,0xee,0x0e,
    0xe0,0xee,0xee,0xe0,0xee
  },
  { 10, 10,
    0xee,0xee,0xee,0xee,0xee,
    0xe0,0x00,0x00,0x00,0x0e,
    0x02,0x22,0x88,0x78,0x80,
    0x02,0x28,0x22,0x22,0x20,
    0x02,0x28,0x87,0x82,0x80,
    0xe0,0x28,0x87,0x82,0x80,
    0xe0,0x28,0x88,0x80,0x80,
    0xe0,0x28,0x88,0x78,0x70,
    0x02,0x00,0x00,0x80,0x00,
    0x00,0xee,0xee,0x0e,0xee
  },
  { 10, 10,
    0xe0,0x00,0x00,0x00,0x0e,
    0x02,0x28,0x87,0x88,0x80,
    0x02,0x82,0x22,0x22,0x20,
    0x02,0x88,0x78,0x28,0x70,
    0x02,0x88,0x78,0x28,0x70,
    0xe0,0x28,0x88,0x88,0x80,
    0xe0,0x28,0x88,0x08,0x80,
    0x02,0x28,0x87,0x87,0x80,
    0x08,0x0e,0x08,0x00,0x00,
    0x00,0xee,0xe0,0xee,0xee
  },
  { 10, 10,
    0xe0,0x00,0x00,0x00,0x0e,
    0x02,0x28,0x87,0x88,0x80,
    0x02,0x82,0x22,0x22,0x20,
    0x02,0x88,0x78,0x28,0x70,
    0x02,0x88,0x78,0x28,0x70,
    0xe0,0x28,0x88,0x28,0x80,
    0xe0,0x28,0x88,0x08,0x80,
    0x02,0x28,0x87,0x87,0x80,
    0x20,0x08,0x00,0x00,0x00,
    0xee,0x08,0x0e,0xee,0x0e
  },
  { 10, 10,
    0xee,0xee,0xee,0xee,0xee,
    0xe0,0x00,0x00,0x00,0x0e,
    0x02,0x22,0x87,0x88,0x80,
    0x02,0x22,0x22,0x22,0x20,
    0x02,0x28,0x78,0x28,0x70,
    0xe0,0x28,0x78,0x08,0x70,
    0xe0,0x28,0x88,0x08,0x80,
    0xe0,0x28,0x87,0x87,0x80,
    0xee,0x08,0x00,0x00,0x88,
    0xee,0x08,0x0e,0xee,0x08
  }
};

class Enemy :
  public Box {
  public:
    byte subtype;
    bool angry=false;
    bool active;
    int health;
    int getWidth() {
      return (subtype == E_SMALL) ? 48 : 72;
    }
    int getHeight() {
      return (subtype == E_SMALL) ? 64 : 80;
    }
    int getGravity() {
      if (health > 0)
        return 4;
      else
        return 10;
    }
    int getXFriction() {
      return 0;
    }
    int getXBounce() {
      if (health > 0) {
        return 100;
      }
      else {
        return -1;
      }
    }
    int getYBounce() {
      return 0;
    }
    int getMaxHealth() {
      return (subtype == E_SMALL) ? 2 : 4;
    }
    int getMaxSpeed() {
      return 32;
    }

    int update() {
      if (active) {
        Box::update();
        //respawn in "angry" mod whel enemies falls at the bottom of the map
        if (y > world.getHeight()) {
          if (health > 0) {
            angry=true;
            x = world.getWidth() / 2 - getWidth() / 2;
            y = 0;
            vx = dir * 20;
            ////pb.sound.playPattern(enemy_felt_sound, 2);
            Audio::play<3>(enemy_felt_sound);
          }
          else {
            active = false;
          }
        }
      }
      return 0;
    }
    
    void draw() {
      //bool angry = (abs(vx) > 10) && (health > 0);

      if (isOffScreen()) {
        return;
      }
      int8_t flip = (dir > 0) ? NOFLIP : FLIPH;
      if (subtype == E_SMALL) {
        byte frame = (dir * x / 16 + 255) % 5; //get the current frame from the x position. Add 255 to avoid being under 0.
        #ifdef POKITTO
          pb.display.setInvisibleColor(PINK);
          pb.display.drawBitmap(toScreenX(x), toScreenY(y),angry?smallEnemyAngryBitmap[frame]:smallEnemyBitmap[frame], NOROT, flip);
        #else
          pb.display.setTransparentColor(PINK);
          pb.display.drawBitmapRot(toScreenX(x), toScreenY(y),angry?smallEnemyAngryBitmap[frame]:smallEnemyBitmap[frame], NOROT, flip);
        #endif // POKITTO

      }
      else {
        byte frame = (dir * x / 16 + 255) % 5; //get the current frame from the x position. Add 255 to avoid being under 0.
        #ifdef POKITTO
         pb.display.setInvisibleColor(PINK);
          pb.display.drawBitmap(toScreenX(x), toScreenY(y),angry?bigEnemyAngryBitmap[frame]:bigEnemyBitmap[frame], NOROT, flip);
        #else
          pb.display.setTransparentColor(PINK);
          pb.display.drawBitmapRot(toScreenX(x), toScreenY(y),angry?bigEnemyAngryBitmap[frame]:bigEnemyBitmap[frame], NOROT, flip);
        #endif // POKITTO

      }
    }
};

/////////////////////////////////////////////
///////////////////////////////////////////// ENEMY ENGINE
/////////////////////////////////////////////

#define NUMENEMIES 20
Enemy enemies[NUMENEMIES];

class EnemiesEngine {
  public:
    int nextSpawnCount;
    void init() {
      nextSpawnCount = 10;
      for (byte i = 0; i < NUMENEMIES; i++) {
        enemies[i].active = false;
        enemies[i].health = 0;
      }
    }

    void addEnemy() {
      for (byte i = 0; i < NUMENEMIES; i++) {
        if (!enemies[i].active) {
          enemies[i].active = true;
          if ((random(0, 6) == 0) && (world.mapNumber != 0)) { //randomly spawn a few big monsters
            enemies[i].subtype = E_BIG;
          }
          else {
            enemies[i].subtype = E_SMALL;
          }
          enemies[i].health = enemies[i].getMaxHealth();
          enemies[i].x = world.getWidth() / 2 - enemies[i].getWidth() / 2;
          enemies[i].y = 0;
          #ifdef POK_SIM
          enemies[i].vx = random(0, 1) * 20 - 10;
          #else
          enemies[i].vx = random(0, 2) * 20 - 10;
          #endif // POK_SIM
          enemies[i].vy = 0;
          enemies[i].angry=false;
          return;
        }
      }
    }

    void update() {
      for (byte j = 0; j < NUMBULLETS; j++) {
        //skip inactive bullets
        if (bullets[j].timeLeft <= 0) {
          continue;
        }
        for (byte i = 0; i < NUMENEMIES; i++) {
          //skip dead enemies
          if (enemies[i].health <= 0) {
            continue;
          }
          //skip bullets with a low speed (falling particles) except explosions, mines and grenades
          if ((abs(bullets[j].vx) < 20) && !((bullets[j].subtype == W_EXPLOSION) || (bullets[j].subtype == W_MINE) || (bullets[j].subtype == W_GRENADE))) {
            break;
          }
          if (collideRectRect(enemies[i].x, enemies[i].y, enemies[i].getWidth(), enemies[i].getHeight(),
                                 bullets[j].x, bullets[j].y, bullets[j].getWidth(), bullets[j].getHeight())) {
            if (bullets[j].explodes()) {
              bullets[j].timeLeft = 1;
            }
            if (bullets[j].destroyOnEnemyContact()) {
              bullets[j].vx = (bullets[j].vx * bullets[j].getXBounce()) / 100;
            }
            enemies[i].health -= bullets[j].getDamage();
            //make the ennemy jump when dead
            if (enemies[i].health <= 0) {
              int dir;
              if (bullets[j].subtype == W_EXPLOSION) { //fly away from the explosive
                dir = (((enemies[i].x + enemies[i].getWidth() / 2) - (bullets[j].x + bullets[j].getWidth() / 2)) > 0) ? 1 : -1;
              }
              else { //fly in the same direction that the incoming bullet
                dir = bullets[j].vx > 0 ? 1 : -1;
              }
              //throw the enemy in the air
              enemies[i].vx = dir * random(24, 32);
              enemies[i].vy = random(-48, -64);
              ////pb.sound.playPattern(enemy_death_sound, 1);
              Audio::play<3>(enemy_death_sound);
              
            }
            else {
              if (bullets[j].subtype == W_CLUB) { // if not dead, go away from the player when hit by a club
                int dir = (enemies[i].x + enemies[i].getWidth() / 2) - (player.x + player.getWidth() / 2) > 0 ? 1 : -1;
                enemies[i].vx = dir * abs(enemies[i].vx);
              }
            }
          }
        }
      }
      nextSpawnCount--;
      if (!nextSpawnCount) { //spawn enemies
        //spawn rate increase slowly depending on score
        //when score is 0, monsters spawn every 60 frames (3 s)
        //when score is 50 monsters swpan every 30 frames (1.5 s)
        //they won't spaw faster than every 10 frames (0.5 s)
        if(world.mapNumber==0)
            nextSpawnCount = map(player.score, 0, 50, 60, 30);
        else
            nextSpawnCount = map(player.score, 0, 50, 60, 30);

        nextSpawnCount = (nextSpawnCount>10)?nextSpawnCount:10;

        addEnemy();
      }
      for (byte i = 0; i < NUMENEMIES; i++) {
        enemies[i].update();
      }

    }

    void draw() {
      for (byte i = 0; i < NUMENEMIES; i++) {
        if (enemies[i].active) {
          enemies[i].draw();
        }
      }
    }

};

EnemiesEngine enemiesEngine;


///////////////////////////////////////////// CRATE

const uint8_t crateBitmap[] PROGMEM = {
    6,6,
    0x00,0x00,0x00,
    0x09,0xaa,0x90,
    0x09,0x44,0x90,
    0x09,0x99,0x90,
    0x09,0xaa,0x90,
    0x00,0x00,0x00
};

class Crate :
  public Box {
  public:
    int getWidth() {
      return 48;
    }
    int getHeight() {
      return 48;
    }

    void init() {
      vy = 0;
      bool goodSpot;
      do { //pick a random location somewhere in the world (distance from the border = 1 sprite max)
        x = random(SPRITE_SIZE * SCALE , world.getWidth() - SPRITE_SIZE * SCALE - getWidth());
        y = random(SPRITE_SIZE * SCALE, world.getHeight() - SPRITE_SIZE * SCALE - getHeight());
        goodSpot = true;
        if ((abs(player.x - x) < 128) || (abs(player.y - y) < 128))
          goodSpot = false; //too close to the player
        if ((x > (world.getWidth() / 2 - 128)) && (x < (world.getWidth() / 2 + 128)) && (y < 336))
          goodSpot = false; //avoid the top central zone where mobs spawn
      }
      while (!goodSpot);
    }

    void update() {
      Box::update();
      //reinit the crate if it felt out of the world
      if (y > world.getHeight()) {
        init();
      }
      //pick random weapon when taken by the player
      if (collideRectRect(x, y, getWidth(), getHeight(),
                             player.x, player.y, player.getWidth(), player.getHeight())) {
        player.score++;
        ////pb.sound.playOK();
        Audio::play(ok_sound);
        
        //add a random value to the weapon type inferior to the number of weapons
        //to avoid picking the same weapon
        player.weapon.subtype = (player.weapon.subtype + random(1, scbSave.unlockedWeapons + 1)) % (scbSave.unlockedWeapons + 1);
        switch (player.weapon.subtype) {
          case W_CLUB :
            popup("CLUB");
            break;
          case W_PISTOL :
            popup("PISTOL");
            break;
          case W_AKIMBO :
            popup("AKIMBO");
            break;
          case W_REVOLVER :
            popup("REVOLVER");
            break;
          case W_SNIPER :
            popup("SNIPER");
            break;
          case W_SHOTGUN :
            popup("SHOTGUN");
            break;
          case W_RIFLE :
            popup("RIFLE");
            break;
          case W_MACHINEGUN :
            popup("MACHINEGUN");
            break;
          case W_DISK :
            popup("DISK");
            break;
          case W_LASER :
            popup("LASER");
            break;
          case W_GRENADE :
            popup("GRENADE");
            break;
          case W_ROCKET :
            popup("ROCKET");
            break;
          case W_MINE :
            popup("MINE");
            break;
        }
        bool shouldSave=false;
        if (world.mapNumber == 0) {
          switch (player.score) {
            case (SCORETHRESHOLD_1):
              if (scbSave.unlockedWeapons < W_RIFLE) {
                scbSave.unlockedWeapons = W_RIFLE;
                player.weapon.subtype = W_RIFLE;
                popup("RIFLE UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 2);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_2):
              if (scbSave.unlockedWeapons < W_SHOTGUN) {
                scbSave.unlockedWeapons = W_SHOTGUN;
                player.weapon.subtype = W_SHOTGUN;
                popup("SHOTGUN UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 2);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_3):
              if (scbSave.unlockedMaps < 1) {
                scbSave.unlockedMaps = 1;
                popup("NEW MAP UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
          }
        }
        if (world.mapNumber == 1) {
          switch (player.score) {
            case (SCORETHRESHOLD_1):
              if (scbSave.unlockedWeapons < W_ROCKET) {
                scbSave.unlockedWeapons = W_ROCKET;
                player.weapon.subtype = W_ROCKET;
                popup("ROCKETS UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_2):
              if (scbSave.unlockedWeapons < W_CLUB) {
                scbSave.unlockedWeapons = W_CLUB;
                player.weapon.subtype = W_CLUB;
                popup("CLUB UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_3):
              if (scbSave.unlockedWeapons < W_REVOLVER) {
                scbSave.unlockedWeapons = W_REVOLVER;
                player.weapon.subtype = W_REVOLVER;
                popup("REVOLVER UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_4):
              if (scbSave.unlockedWeapons < W_MINE) {
                scbSave.unlockedWeapons = W_MINE;
                player.weapon.subtype = W_MINE;
                popup("MINES UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_5):
              if (scbSave.unlockedMaps < 2) {
                scbSave.unlockedMaps = 2;
                popup("NEW MAP UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
          }
        }
        if (world.mapNumber == 2) {
          switch (player.score) {
            case (SCORETHRESHOLD_1):
              if (scbSave.unlockedWeapons < W_SNIPER) {
                scbSave.unlockedWeapons = W_SNIPER;
                player.weapon.subtype = W_SNIPER;
                popup("SNIPER UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_2):
              if (scbSave.unlockedWeapons < W_MACHINEGUN) {
                scbSave.unlockedWeapons = W_MACHINEGUN;
                player.weapon.subtype = W_MACHINEGUN;
                popup("MACHINEGUN UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_3):
              if (scbSave.unlockedWeapons < W_GRENADE) {
                scbSave.unlockedWeapons = W_GRENADE;
                player.weapon.subtype = W_GRENADE;
                popup("GRENADES UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_4):
              if (scbSave.unlockedWeapons < W_AKIMBO) {
                scbSave.unlockedWeapons = W_AKIMBO;
                player.weapon.subtype = W_AKIMBO;
                popup("AKIMBO UNLOCKED!", 40);
                ////pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_5):
              if (scbSave.unlockedMaps < 3) {
                scbSave.unlockedMaps = 3;
                popup("NEW MAP UNLOCKED!", 40);
                //pb.sound.playPattern(power_up_sound, 0);
                Audio::play<3>(power_up_sound);
                shouldSave=true;
              }
              break;
          }
        }
        if (world.mapNumber == 3) {
          switch (player.score) {
            case (SCORETHRESHOLD_3):
              if (scbSave.unlockedWeapons < W_DISK) {
                scbSave.unlockedWeapons = W_DISK;
                player.weapon.subtype = W_DISK;
                popup("DISK UNLOCKED!", 40);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_4):
              if (scbSave.unlockedWeapons < W_LASER) {
                scbSave.unlockedWeapons = W_LASER;
                player.weapon.subtype = W_LASER;
                popup("LASER UNLOCKED!", 40);
                shouldSave=true;
              }
              break;
            case (SCORETHRESHOLD_5):
              if (scbSave.unlockedMaps < 4) {
                scbSave.unlockedMaps = 4;
                popup("LAST MAP UNLOCKED!", 40);
                shouldSave=true;
              }
              break;
          }
        }
        if(shouldSave)
            saveEEPROM();
        init(); //move the crate
      }
    }

    void draw() {
      if (isOffScreen())
        return;
      #ifdef POKITTO
        pb.display.setInvisibleColor(14);
        pb.display.drawBitmap(toScreenX(x), toScreenY(y), crateBitmap);
      #else
        pb.display.setTransparentColor(14);
        pb.display.drawBitmap(toScreenX(x), toScreenY(y), crateBitmap);
      #endif // POKITTO
    }
};

Crate crate;

void mainMenu() {
  uint8_t menu_selected=0;
  int t_intro=50;
  bool credits=false;
  auto& music = Audio::play<0>(main_theme);
  music.setLoop(true);
  while(true)
  {
      if(!pb.update())
        continue;
      PD::update();
      ESP.wdtFeed();
      if(t_intro > 0)
        t_intro--;
      if(t_intro > 30)
      {
        pb.display.fillScreen(INDIGO);
        pb.display.setInvisibleColor(PINK);
        pb.display.drawBitmap(23,37,bl_ackrain);
        continue;
      }
      if(credits)
      {
          pb.display.fillScreen(BLUE);
          pb.display.setColor(INDIGO);
          pb.display.fillRect(0,_LCDHEIGHT/2,_LCDWIDTH,_LCDHEIGHT/2+1);
          pb.display.setColor(DARK_GRAY);
          pb.display.fillRoundRect(2,5,_LCDWIDTH-4,_LCDHEIGHT-9,5);
          pb.display.setInvisibleColor(PINK);
          pb.display.setColor(WHITE,PINK);
          pb.display.setCursor(30,6);
          pb.display.print(VERSION);
          pb.display.setCursor(25,14);
          pb.display.print("this is an conversion");
          pb.display.setCursor(18,21);
          pb.display.print("of the 2010 PC game.");
          pb.display.setCursor(6,27);
          pb.display.print("developed by Rodot ported");
          pb.display.setCursor(6,34);
          pb.display.print("to pokitto by @bl_ackrain");


          pb.display.drawBitmap(20,_LCDHEIGHT-43,qr_code);
          pb.display.drawBitmap(_LCDWIDTH-50,0,pokitto_logo);
          pb.display.drawBitmap(0,0,supercratebox_logo_half);
          pb.display.drawBitmap(_LCDWIDTH-34,_LCDHEIGHT-40+2,pokitto_player);

          ESP.wdtFeed();
          if(pb.buttons.pressed(BTN_A) || pb.buttons.pressed(BTN_B))
            credits=false;
          continue;
      }

      pb.display.fillScreen(C_BLUE);
      pb.display.setColor(WHITE);
      int Y=_LCDHEIGHT/2;
      pb.display.fillRect(0,Y,_LCDWIDTH,_LCDHEIGHT-Y+1);
      for(int i=0;i < 7;i++){
            pb.display.fillCircle(cloudX[i],Y,cloudS[i]);
            cloudX[i]++;
            if(cloudX[i] > _LCDWIDTH+64)
                cloudX[i]=-64;
      }
      for (byte x = SPRITE_SIZE; x < _LCDWIDTH-SPRITE_SIZE; x += SPRITE_SIZE) {
        pb.display.setInvisibleColor(BLACK);
        pb.display.drawBitmap(x, 7, beam);

       }
       for (byte x = SPRITE_SIZE; x < _LCDWIDTH-SPRITE_SIZE; x += SPRITE_SIZE) {
        pb.display.setInvisibleColor(BLACK);
        pb.display.drawBitmap(x, _LCDHEIGHT-4, fire[(pb.frameCount%12)/4]);

       }
       pb.display.setColor(BROWN);
       pb.display.fillRect(21,13,1,40);
       pb.display.fillRect(87,13,1,40);
       for (byte y = 0; y < _LCDHEIGHT; y += SPRITE_SIZE) {
          pb.display.drawBitmap(0, y, bricks);
          pb.display.drawBitmap(_LCDWIDTH - SPRITE_SIZE, y, bricks);
      }

       for (byte x = 0; x < 12; x ++) {
          pb.display.drawBitmap(18+x*SPRITE_SIZE, 47, beam);
          pb.display.drawBitmap(18+x*SPRITE_SIZE, 77, beam);

       }
       for (byte y = 0; y < 4; y ++) {
            pb.display.drawBitmap(18,53+ y*SPRITE_SIZE, bricks);
            pb.display.drawBitmap(84,53+ y*SPRITE_SIZE, bricks);
       }


      pb.display.setInvisibleColor(PINK);

      if(t_intro < 30)
      {
          pb.display.drawBitmap(30,1-t_intro*2,supercratebox_logo);
          pb.display.drawBitmap(33+t_intro*2,37,pokitto_logo);
          pb.display.drawBitmap(70-t_intro*2,25,pokitto);
      }

      if(t_intro < 1)
      {
          if(menu_selected==0)
          {
              pb.display.setColor(BLACK);
              pb.display.fillRect(24,55,60,9);
              pb.display.drawBitmap(38,55,supercratebox_play_on);
              pb.display.drawBitmap(26,66,supercratebox_credits_off);
          }else
          {
              pb.display.setColor(BLACK);
              pb.display.fillRect(24,66,60,9);
              pb.display.drawBitmap(38,55,supercratebox_play_off);
              pb.display.drawBitmap(26,66,supercratebox_credits_on);
          }
      }
      else
        continue;



      if(pb.buttons.pressed(BTN_A))
       {
           if(menu_selected==0)
           {
               world.chooseMap();
               break;
           }
           if(menu_selected==1)
               credits=true;

       }

      if(pb.buttons.pressed(BTN_UP))
      {
          menu_selected--;
          //pb.sound.playOK();
          Audio::play(ok_sound);
      }

      if(pb.buttons.pressed(BTN_DOWN))
      {
          menu_selected++;
          //pb.sound.playOK();
          Audio::play(ok_sound);
      }
      menu_selected%=2;

  //#ifdef PICOBOY
     ESP.wdtFeed();
     //yield()
  //#endif // PICOBOY
  }


  pb.pickRandomSeed();
  //pb.battery.show = false;
}

void gamePaused() {
  auto& music = Audio::play<0>(main_theme);
  music.setLoop(true);
  while (1) {
    if (pb.update()) {
      PD::update();
      drawAll();
      //#ifdef POKITTO
        pb.display.setColor(BLACK);
        pb.display.fillRect(0,30,_LCDWIDTH,25);
        pb.display.setColor(WHITE);
      //#else
        //pb.display.setTextColor(WHITE,BLACK);
      //#endif

      pb.display.setCursor(32,32);
      pb.display.print("GAME PAUSED");
      pb.display.setCursor(25,40);
      pb.display.print("B: Save & Quit");
      pb.display.setCursor(25,48);
      pb.display.print("C: Resume");

      if (pb.buttons.pressed(BTN_C)) {
        return;
      }
      if (pb.buttons.pressed(BTN_B)) {
        world.addScore(player.score);
        saveEEPROM();
        world.chooseMap();
        return;
      }
    }
    //#ifdef PICOBOY
    //yield()
    ESP.wdtFeed();
    //#endif // PICOBOY
  }

}

void initGame() {
  player.init();
  enemiesEngine.init();
  crate.init();
  player.weapon.subtype = 0;
  shakeTimeLeft = 0;
}

void drawAll() {
  world.draw();
  crate.draw();
  enemiesEngine.draw();
  player.draw();
  if (!player.dead && world.mapNumber) {
    drawCompass();
  }
  //draw explosions
  for (byte i = 0; i < NUMBULLETS; i++) {
    bullets[i].draw();
  }

  int y = 8;
  int x = (_LCDWIDTH / 2) - (player.score<10?1:2)  * pb.display.fontWidth / 2;
  //pb.display.println(player.score);
  char scr[10];
  sprintf(scr,"%d",player.score);
  print_border(x,y,scr,WHITE,BLACK);
  updatePopup();

  #ifdef POKITTO
      pb.display.setInvisibleColor(PINK);
      pb.display.setColor(WHITE, BLACK);
  #else
      pb.display.setTextColor(WHITE, BLACK);
      pb.display.setCursor(1,_LCDHEIGHT-7);
      pb.display.printf("CPU:%d%%",pb.getCpuLoad());
  #endif // POKITTO

}

void loadEEPROM() {
    scbSave.begin("SuCrBoxC",scbSave);
    world.mapNumber = scbSave.unlockedMaps;
}

void saveEEPROM() {
    scbSave.saveCookie();
}

void printCentered(const char* text) {
  pb.display.cursorX = (_LCDWIDTH / 2) - (strlen((const char*)text) * pb.display.fontSize * pb.display.fontWidth / 2);
  pb.display.print(text);
}

void print_border(int16_t x,int16_t y,const char* text,uint8_t cf,uint8_t cb)
{
    #ifdef POKITTO
        pb.display.setInvisibleColor(PINK);
        pb.display.setColor(cb,PINK);
    #else
        pb.display.setTextColor(cb);
    #endif // POKITTO

    for(int i=-1; i < 2;i++)
        for(int j=-1; j < 2;j++)
        {
            pb.display.setCursor(x+i, y+j);
            pb.display.print(text);
        }
    #ifdef POKITTO
        pb.display.setColor(cf,PINK);
    #else
        pb.display.setTextColor(cf);
    #endif // POKITTO

    pb.display.setCursor(x, y);
    pb.display.print(text);
}

void popup(const char* text) {
  popup(text, 30);
}
void popup(const char* text, uint8_t duration) {
  _popupText = text;
  _popupTimeLeft = duration + 12;
}

void updatePopup() {
  if (_popupTimeLeft) {
    uint8_t yOffset = 0;
    if (_popupTimeLeft < 12) {
      yOffset = _popupTimeLeft - 12;
    }

    pb.display.fontSize = 1;

    int x=toScreenX(player.x);
    int y=toScreenY(player.y)-5+yOffset;
    if((x+strlen(_popupText)*pb.display.fontWidth) > world.getWidth()/SCALE)
        x=world.getWidth()/SCALE - strlen(_popupText)*pb.display.fontWidth;
    if((x+strlen(_popupText)*pb.display.fontWidth) > _LCDWIDTH-6)
        x=_LCDWIDTH-6 - strlen(_popupText)*pb.display.fontWidth;

    print_border(x,y,_popupText,WHITE,BLACK);

    _popupTimeLeft--;
  }
}

void drawCompass() {
  //if (crate.isOffScreen()) {
  int x = (crate.x + crate.getWidth() / 2 - player.x - player.getWidth() / 2) / SCALE;
  int y = (crate.y + crate.getWidth() / 2 - player.y - player.getHeight() / 2) / SCALE;
  int dist = sqrt(x * x + y * y);
  if (dist > 40  ) {
    int dx = toScreenX(player.x + player.getWidth() / 2)   + (16 * x / dist);
    int dy = toScreenY(player.y + player.getHeight() / 2)  + (16 * y / dist);

    #ifdef POKITTO
        pb.display.setColor(WHITE);
        pb.display.drawLine(dx, dy, dx + x / 8, dy + y / 8);
    #else
        pb.display.drawLine(dx, dy, dx + x / 8, dy + y / 8,WHITE);
    #endif // POKITTO
  }
}

void _init() {
  loadEEPROM();
  //pb.sound.chanVolumes[2] = 1;
  mainMenu();
  Audio::stop<0>();
  //world.chooseMap();
}

void _gamesetup() {
    pb.begin();
    pb.setFrameRate(30);

    pb.display.loadRGBPalette(palettePico);
    pb.display.setFont(font3x5);
    pb.display.setInvisibleColor(14);//pink
    _init();
}

///////////////////////////////////////////// LOOP
void _gameloop() {
    if (!pb.update()) return;
    if (pb.buttons.pressed(BTN_C)) {
      gamePaused();
      Audio::stop<0>();
    }

    crate.update();
    player.update();
    enemiesEngine.update();
 /*
    saveEEPROM(); //it checks if the values have changed before writting so it won't wear out the EEPROM
*/
    //camera smoothing
    int x = (player.x + player.getWidth()/2)/SCALE - _LCDWIDTH/2;
    int y = (player.y + player.getHeight()/2)/SCALE - _LCDHEIGHT/2;
    cameraX = (3*cameraX + x)/4;
    cameraY = (3*cameraY + y)/4;

    //update camera
    if (world.getWidth()/SCALE <= _LCDWIDTH) {
      cameraX = -(_LCDWIDTH-world.getWidth()/SCALE)/2;
    } else {
      cameraX = (player.x + player.getWidth() / 2) / SCALE - _LCDWIDTH / 2;
      cameraX = constrain(cameraX, 0, world.getWidth() / SCALE - _LCDWIDTH);
    }

    if (world.getHeight()/SCALE <= _LCDHEIGHT) {
      cameraY = -(_LCDHEIGHT-world.getHeight()/SCALE)/2;
    } else {
      cameraY = (player.y + player.getHeight() / 2) / SCALE - _LCDHEIGHT / 2;
      cameraY = constrain(cameraY, 0, world.getHeight() / SCALE - _LCDHEIGHT - SPRITE_SIZE / 2);
    }

    if (shakeTimeLeft > 0) {
      shakeTimeLeft --;
      cameraX += random(- 1, 2) * shakeAmplitude;
      cameraY += random(- 1, 2) * shakeAmplitude;
    }

    drawAll();
    PD::update();
    ESP.wdtFeed();

    //check for player - monsters collisions
    for (byte i = 0; i < NUMENEMIES; i++) {
      if (collideRectRect(enemies[i].x, enemies[i].y, enemies[i].getWidth(), enemies[i].getHeight(),
                             player.x, player.y, player.getWidth(), player.getHeight())) {
        if (enemies[i].health > 0) {
          player.dead = true;
          int dir = (((enemies[i].x + enemies[i].getWidth() / 2) - (player.x + player.getWidth() / 2)) > 0) ? -1 : 1;
          player.kill(dir);
          break;
        }
      }
    }
    //check for player - bullet collisons
    for (byte i = 0; i < NUMBULLETS; i++) {
      //skip inactive bullets
      if (bullets[i].timeLeft <= 0) {
        continue;
      }
      if (bullets[i].damagePlayer() && collideRectRect(bullets[i].x, bullets[i].y, bullets[i].getWidth(), bullets[i].getHeight(),
          player.x, player.y, player.getWidth(), player.getHeight())) {
        player.kill(bullets[i].dir);
      }
    }

    if (player.dead) {
      int Count = 20;
      _popupTimeLeft=0;
      //if (!_popupTimeLeft) { //if the "new highscore" popup is no here
      //  popup("GAME OVER!", 20);
      //}
      bool new_hi_score=false;
      if (world.addScore(player.score)) {
        new_hi_score=true;
        saveEEPROM();
      }

      while (1) {
        if (pb.update()) {
          Count--;
          player.update();
          enemiesEngine.update();
          drawAll();
          pb.display.setColor(BLACK);
          pb.display.fillRect(0,30,_LCDWIDTH,25);
          pb.display.setColor(WHITE,BLACK);
          pb.display.cursorY=33;
          printCentered("GAME OVER");
          pb.display.cursorY=40;
          char txt[20];
          sprintf(txt,"CRATES: %d",player.score);
          printCentered(txt);
          pb.display.cursorY=47;
          if (new_hi_score)
             sprintf(txt,"NEW BEST: %d",scbSave.score[world.mapNumber]);
          else
             sprintf(txt,"BEST: %d",scbSave.score[world.mapNumber]);
          printCentered(txt);
          PD::update();
          ESP.wdtFeed();
          if(Count > 0)
            continue;

          if (pb.buttons.pressed(BTN_A)) {
            break;
          }
          if (pb.buttons.pressed(BTN_B)) {
            //pb.sound.playOK();
            Audio::play(ok_sound);
            world.chooseMap();
            break;
          }
          if (pb.buttons.pressed(BTN_C)) {
           // pb.sound.playOK();
           Audio::play(ok_sound);
            mainMenu();
            Audio::stop<0>();
            break;
          }
        }
        //#ifdef PICOBOY
        //yield();
        ESP.wdtFeed();
        //#endif // PICOBOY
      }
      initGame();
    }
}
